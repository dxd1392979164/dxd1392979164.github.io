<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java的四种内部类]]></title>
    <url>%2F2019%2F08%2F10%2FJava%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java四种内部类因为之前复习到staic关键字，因为static修饰类只能修饰内部类，所以就对内部类进行了复习，所以写下这篇博客。 成员内部类成员内部类是最普通的内部类，它的定义为位于另一个类的内部。 一般格式如下,因为类C相对与类D在外面，我们且称类C为外部类。 12345class C&#123; class D&#123; &#125;&#125; 成员内部类的特性： 1.内部类可以无条件访问外部类的属性和方法（包括private成员和静态成员）。123456789101112131415161718192021class C &#123; private String name = &quot;外部类&quot;; private static String staticName = &quot;外部类的静态成员&quot;; public void run() &#123; System.out.println(&quot;外部类奔跑&quot;); &#125; public static void staticRun() &#123; System.out.println(&quot;外部类的静态方法&quot;); &#125; class D &#123; public void say() &#123; System.out.println(name); System.out.println(staticName); run(); staticRun(); &#125; &#125;&#125; 2.外部类想要访问内部类的属性和方法时就必须通过内部类的对象，通过对象访问。 123456789101112131415161718192021222324class C &#123; private String name = &quot;外部类&quot;; private static String staticName = &quot;外部类的静态成员&quot;; public void run() &#123; System.out.println(&quot;外部类奔跑&quot;); &#125; public static void staticRun() &#123; System.out.println(&quot;外部类的静态方法&quot;); &#125; public void test() &#123; D d = new D(); d.say(); &#125; class D &#123; public void say() &#123; System.out.println(name); System.out.println(staticName); run(); staticRun(); &#125; &#125;&#125; 3.如果成员内部类的属性或者方法与外部类的同名，将导致外部类的这些属性与方法在内部类被隐藏，需要按照该格式调用。 12外部类.this.成员变量外部类.this.成员方法 4.那如何创建一个内部类对象了? 前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125; class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 5.内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及默认访问权限。外部类只能被 public和包访问两种权限修饰。由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 格式如下： 12345678class A &#123; public void testA() &#123; class B &#123;// 局部内部类 &#125; &#125;&#125; 注意: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。 匿名内部类1.匿名内部类也就是没有名字的内部类正因为没有名字。 2.所以匿名内部类只能使用一次，它通常用来简化代码编写。 3.但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。 1234567891011121314151617181920public class Demo3 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub driveCar(new Car() &#123; @Override public void drive() &#123; System.out.println(&quot;驾驶着汽车&quot;); &#125; &#125;); &#125; public static void driveCar(Car car) &#123; car.drive(); &#125;&#125;interface Car &#123; void drive();&#125; 注意： 匿名内部类不能定义任何静态成员、方法。 匿名内部类中的方法不能是抽象的； 匿名内部类必须实现接口或抽象父类的所有抽象方法。 匿名内部类访问的外部类成员变量或成员方法必须用static修饰； 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。这个内部类就属于外部类本身，而不属于外部类的某个对象。 1234567891011121314151617public class Demo4 &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125;class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 注意： 1.非静态内部类中不允许定义静态成员 2.静态内部类不能使用外部类的非static成员变量或者方法]]></content>
      <categories>
        <category>Java学习总结</category>
      </categories>
      <tags>
        <tag>Java基础复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式什么是单例设计模式？ 通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。并且自行实例化向整个系统提供。 懒汉式需要： （1）将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 （2）在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。 （3）定义一个静态方法返回这个唯一对象。 12345678910111213public class Monitor &#123; private static Monitor monitor = null; private Monitor() &#123;&#125; public static Monitor getMonitor() &#123; if(monitor == null) &#123; monitor = new Monitor(); &#125; return monitor; &#125;&#125; 优点：实现起来比较简单，当类Monitor被加载的时候，静态变量static的monitor未被创建并分配内存空间，当getMonitor方法第一次被调用时，初始化monitor变量，并分配内存，因此在某些特定条件下会节约了内存。 缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态。上述代码还是不能保证一个班长实例的，因为存在线程安全问题。假如线程A执行到了monitor = new Monitor();，此时班长对象还没创建，线程B执行到判断 monitor == null时，条件为true，于是也进入到if里面去执行monitor = new Monitor();了，这样内存中就出现了两个班长实例了。 线程安全的懒汉模式12345678910111213public class Monitor &#123; private static Monitor monitor = null; private Monitor() &#123;&#125; // 静态方法返回该实例，加synchronized关键字实现同步 public static synchronized Monitor getMonitor() &#123; if (monitor == null) &#123; monitor = new Monitor(); &#125; return monitor; &#125;&#125; 优点：在多线程情形下，保证了“懒汉模式”的线程安全。 缺点：多线程情形下，synchronized方法通常效率低。 12345678910public static Monitor getMonitor() &#123; if (monitor == null) &#123; synchronized (Monitor.class) &#123; if (monitor == null) &#123; monitor = new Monitor(); &#125; &#125; &#125; return monitor;&#125; 第一层判断如果 monitor 实例不为空，那皆大欢喜，说明对象已经被创建过了，直接返回该对象即可，不会走到 synchronized 部分，所以班长对象被创建了之后，不会影响到性能。第二层判断是在 synchronized 代码块里面，为什么要再做一次判断呢？假如 monitor 对象是 null，那么第一层判断后，肯定有很多线程已经进来第一层了，那么即使在第二层某个线程执行完了之后，释放了锁，其他线程还会进入synchronized代码块，如果不判断，那么又会被创建一次，这就导致了多个班长对象的创建。所以第二层起到了一个防范作用。 饿汉式12345678910public class Monitor &#123; private static final Monitor monitor = new Monitor(); private Monitor() &#123;&#125; public static Monitor getMonitor() &#123; return monitor; &#125;&#125; 优点：实现起来简单，没有多线程同步问题。缺点：当类Monitor 被加载的时候，会初始化static的monitor，静态变量被创建并分配内存空间，从这以后，这个static的monitor对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。 饿汉式(静态代码块模式)1234567891011public class Monitor &#123; private static final Monitor monitor = null; static &#123; monitor = new Monitor(); &#125; private Monitor() &#123; &#125; public static final Monitor getInstance() &#123; return monitor; &#125;&#125; 这种静态代码块模式，本质上是饿汉模式的一个变种。 静态内部类班长这个对象有个属性是不会变的，那就是他所在的班级，所以班级可以直接定义好。如果想获取CLASS_INFO， 可以通过Monitor.CLASS_INFO,但是但是这样获取的话，因为都是static修饰的，调用Monitor.CLASS_INFO时， 也会执行构造方法将monitor对象初始化，但是我现在不想初始化班长对象（因为会影响性能） 12345678public class Monitor &#123; public static String CLASS_INFO = &quot;通信工程（1）班&quot;; private static Monitor monitor = new Monitor (); private Monitor () &#123;&#125; public static Monitor getMonitor() &#123; return monitor; &#125;&#125; 12345678910111213public class Monitor &#123; public static String CLASS_INFO = &quot;通信工程（1）班&quot;; /** * 静态内部类，用来创建班长对象 */ private static class MonitorCreator &#123; private static Monitor monitor = new Monitor(); &#125; private Monitor() &#123;&#125; public static Monitor getInstance() &#123; return MonitorCreator.monitor; &#125;&#125; 当执行getInstance()方法的时候会去调用内部类MoninorCreator里面的monitor的实例，此时MonitorCreator会 被加载、到内存，在类加载的时候对Monit实例进行初始化。而且当我使用Monitor.CLASS_INFO获取信息时，也不会对 monitor进行初始化。还确保了线程安全，因为JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线 程互斥的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月3]]></title>
    <url>%2F2019%2F08%2F03%2F8%E6%9C%883%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7月31]]></title>
    <url>%2F2019%2F07%2F31%2F7%E6%9C%8831%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7月27]]></title>
    <url>%2F2019%2F07%2F27%2F7%E6%9C%8827%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7月26]]></title>
    <url>%2F2019%2F07%2F26%2F7%E6%9C%8826%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类和常量池]]></title>
    <url>%2F2019%2F07%2F24%2FString%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[String 类和常量池1.1 String 对象的两种创建方式： 12345String str1 = &quot;abcd&quot;;String str2 = new String(&quot;abcd&quot;);//堆中创建一个新的对象String str3 = new String(&quot;abcd&quot;);//堆中创建一个新的对象System.out.println(str1==str2);//falseSystem.out.println(str2==str3);//false String str1 = &quot;abcd&quot;;//先检查字符串常量池中有没有”abcd”，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向”abcd””； 这两种不同的创建方法是有差别的。 第一种方式是在常量池中拿对象； 第二种方式是直接在堆内存空间创建一个新的对象。 注意：只要使用 new 方法，便需要创建新的对象。 1.2 String 类型的常量池比较特殊。它的主要使用方法有两种： ①直接使用双引号声明出来的 String 对象会直接存储在常量池中。 ②如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。 123456String s1 = new String(&quot;计算机&quot;);String s2 = s1.intern();String s3 = &quot;计算机&quot;;System.out.println(s2);//计算机System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象 1.3 字符串拼接:123456789String str1 = &quot;str&quot;;String str2 = &quot;ing&quot;;String str3 = &quot;str&quot; + &quot;ing&quot;;//常量池中的对象String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = &quot;string&quot;;//常量池中的对象System.out.println(str3 == str4);//falseSystem.out.println(str3 == str5);//trueSystem.out.println(str4 == str5);//false 使用String（不可改变，因为使用了final修饰字符数组来保存字符串）尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder（线程安全，可以改变）或者 StringBuffer（线程不安全，可以改变）。 1.4 String s1 = new String(“abc”);这句话创建了几个字符串对象？ 将创建 1 或 2 个字符串。如果池中已存在字符串文字“abc”，则池中只会创建一个字符串“s1”。如果池中没有字符串文字“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。 1234String s1 = new String(&quot;abc&quot;);// 堆内存的地址值String s2 = &quot;abc&quot;;System.out.println(s1 == s2);//（比地址） 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。System.out.println(s1.equals(s2));//（比内容） 输出 true 1.5 8 种基本类型的包装类和常量池 Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long；这4种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。Boolean:true,false 123456789Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueInteger i11 = 333;Integer i22 = 333;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。Integer i1 = new Integer(40);这种情况下会创建新的对象。 Integer 缓存源代码：12345678/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/ public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; Character 缓存源代码：123456public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125; 例子： 12345678910111213Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println(&quot;i1=i2 &quot; + (i1 == i2));System.out.println(&quot;i1=i2+i3 &quot; + (i1 == i2 + i3));System.out.println(&quot;i1=i4 &quot; + (i1 == i4));System.out.println(&quot;i4=i5 &quot; + (i4 == i5));System.out.println(&quot;i4=i5+i6 &quot; + (i4 == i5 + i6)); System.out.println(&quot;40=i5+i6 &quot; + (40 == i5 + i6)); 结果：123456i1=i2 truei1=i2+i3 truei1=i4 falsei4=i5 falsei4=i5+i6 true40=i5+i6 true 语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域]]></title>
    <url>%2F2019%2F07%2F23%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java 内存区域一、运行时数据区域JDK 1.8 之前： JDK 1.8 之后： 2.1.程序计数器 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 2.2 Java 虚拟机栈 与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。） 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用 Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。 StackOverFlowError（栈溢出）：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。OutOfMemoryError（内存溢出）：若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。 那么方法/函数如何调用？ Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。 Java 方法有两种返回方式： return 语句。抛出异常。不管哪种返回方式都会导致栈帧被弹出。 2.3 本地方法栈 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。 2.4 堆 Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法（其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。），所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。 上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 2.5 方法区 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 方法区也被称为永久代。 2.5.1 方法区和永久代的关系 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。 与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。 2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢? HotSpot 虚拟机把方法区当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 2.6 运行时常量池 运行时常量池是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 2.7 直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。 JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 二、HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。 3.1 对象的创建 Step1:类加载检查 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 Step1:分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 内存分配的两种方式： 内存分配并发问题： 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全： CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 Step1:初始化零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 Step1:设置对象头 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 Step1:执行init方法 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始， 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 3.2 对象的内存布局（对象在内存中的存储）在 Hotspot 虚拟机中,对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。 Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的自身运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 3.3 对象的访问定位 建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有①使用句柄和②直接指针两种： ①句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息； ②直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F07%2F22%2FRedis%2F</url>
    <content type="text"><![CDATA[Redis1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库。1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1.NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2.非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3.关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4.总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据。 1.2 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.2.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 2. 下载安装1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 4. 持久化1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 5. Java客户端 Jedis* Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string 123456789101112131415//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 12345678910111213141516171819202122232425//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) &#123; //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); &#125; //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 1234567891011121314151617181920212223242526//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 1234567891011121314//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 1234567891011121314151617//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 123456789101112131415//0.创建一个配置对象JedisPoolConfig config = new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdle(10); //1.创建Jedis连接池对象JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接Jedis jedis = jedisPool.getResource();//3. 使用jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中jedis.close(); * 连接池工具类 12345678910111213141516171819202122232425262728293031public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;]]></content>
      <categories>
        <category>工具和中间件</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F07%2F21%2F7%E6%9C%8821%2F</url>
    <content type="text"><![CDATA[如何查看mysql的安装路径：在命令窗口中输入mysql命令时，提示“mysql不是内部命令也不是可运行的程序”，发现此问题是由于系统的环境变量中未配置MySQL安装目录可执行文件的路径，可是安装MySQL时是默认按照的，此时已经忘记了安装位置，各个盘符中找了一遍，都没有找到。那么要怎样找到其安装的路径呢？ 1.使用MySQL客户端查询 select @@basedir as basePath from dual 2.只需登录MySQL的客户端 输入命令：show variables like “%char%”;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java关键字]]></title>
    <url>%2F2019%2F07%2F20%2FJava%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[this关键字this关键字用于引用当前类实例。当一个对象创建后，Java虚拟机会为这个对象分配一个自身引用的指针，这个指针就是this。 a.使用this调用当前实例的变量。 b.使用this调用当前实例的方法（this可以省略） c.this调用本类中的其他构造方法，调用时要放在构造方法的首行。 d.this还可以返回类的引用。return this来返回某个类对象。 123456789101112131415161718public class Test32 &#123; private int number; public void changeNumber(int number) &#123; System.out.println(&quot;局部变量的number值为：&quot; + (number + 5)); System.out.println(&quot;成员变量的number值为：&quot; + (this.number + 2)); &#125; @Test public void test() &#123; int inputNum = 2; changeNumber(inputNum); &#125;&#125; 123456789101112131415161718public class Test32 &#123; private int number; public void changeNumber(int number) &#123; System.out.println(&quot;局部变量的number值为：&quot; + (number + 5)); System.out.println(&quot;成员变量的number值为：&quot; + (this.number + 2)); &#125; @Test public void test() &#123; int inputNum = 2; this.changeNumber(inputNum); &#125;&#125; 注意： 1.this调用构造方法必须放在首行。 2.this不能用在staic方法中，因为staic方法优先与对象存在。（static是在类加载的时候） 3.如果实例变量和局部变量重名时，Java会先按照局部变量，后实例变量去寻找，如果都找不到，则编译错误，如果使用this.a,则直接去实例变量中找； super关键字作用： 1.在子类中访问父类的的变量和方法。1234567891011121314public class Super &#123; protected int number; protected showNumber() &#123; System.out.println(&quot;number = &quot; + number); &#125;&#125; public class Sub extends Super &#123; void bar() &#123; super.number = 10; super.showNumber(); &#125;&#125; 在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。 2.在子类中访问父类的构造方法。如果子类没用通过super(参数列表)调用父类的构造方法，则会自动默认调用父类的无参构造方法，如果父类没用无参构造方法，此时会报错。 12345678910111213141516171819202122232425262728293031class Father &#123; int age ; public Father()&#123; &#125; public Father(int age) &#123; this.age = age; &#125; public void sayFather() &#123; System.out.println(age); &#125;&#125;class Son extends Father &#123; public String name; public Son() &#123; super();//不写默认调用 &#125; public Son(String name) &#123; super(25); this.name = name; &#125; public String say() &#123; super.sayFather(); System.out.println(super.age); return this.name; &#125;&#125; 注意： 1.访问父类的构造方法时必须放在首行，不写默认调用父类无参构造。 使用 this 和 super 要注意的问题： 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。this、super不能用在static方法中。 static关键字static关键字主要用在三个地方：方法，变量，静态代码块，类，静态导包； 1.修饰成员变量和成员方法：使用static修饰的方法或变量是属于类，不属于单个对象，是所有对象共享的。并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()。 2.静态代码块：静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次。非静态代码块没new一次就会执行一次。非静态代码块是给所有对象进行初始化。构造方法是给对应的对象进行初始化。 3.静态内部类（static修饰的类只能是静态内部类）：静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 4.静态导包(用来导入类中的静态资源，1.5之后的新特性):格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 static详解修饰成员变量和成员方法(常用) 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 调用格式： 类名.静态变量名 类名.静态方法名() 测试方法：1234567891011121314151617181920public class StaticBean &#123; String name; 静态变量 static int age; public StaticBean(String name) &#123; this.name = name; &#125; 静态方法 static void SayHello() &#123; System.out.println(Hello i am java); &#125; @Override public String toString() &#123; return StaticBean&#123; + name=&apos; + name + &apos;&apos;&apos; + age + age + &apos;&#125;&apos;; &#125;&#125; 1234567891011121314public class StaticDemo &#123; public static void main(String[] args) &#123; StaticBean staticBean = new StaticBean(1); StaticBean staticBean2 = new StaticBean(2); StaticBean staticBean3 = new StaticBean(3); StaticBean staticBean4 = new StaticBean(4); StaticBean.age = 33; System.out.println(staticBean+ +staticBean2+ +staticBean3+ +staticBean4); //结果taticBean&#123;name=&apos;1&apos;age33&#125; StaticBean&#123;name=&apos;2&apos;age33&#125; StaticBean&#123;name=&apos;3&apos;age33&#125; StaticBean&#123;name=&apos;4&apos;age33&#125; StaticBean.SayHello();Hello i am java &#125;&#125; 静态代码块 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态代码块的格式是 static {语句体;} 一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 注意：静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。123456789public class Demo2 &#123; static &#123; a = 10; System.out.println(a);//这里会报错，不能访问 &#125; private static int a ;&#125; 静态内部类静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖外围类的创建。它不能使用任何外围类的非static成员变量和方法。 Example（静态内部类实现单例模式）123456789101112131415public class Singleton &#123; 声明为 private 避免调用默认构造方法创建对象 private Singleton() &#123; &#125; 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问 private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。 静态导包 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法 static方法与非static方法静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。 总结：在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 static{}静态代码块与{}非静态代码块(构造代码块) 相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 1234567891011121314151617181920212223242526public class Test &#123; public Test() &#123; System.out.print(默认构造方法！--); &#125; 非静态代码块 &#123; System.out.print(非静态代码块！--); &#125; 静态代码块 static &#123; System.out.print(静态代码块！--); &#125; public static void test() &#123; System.out.print(静态方法中的内容! --); &#123; System.out.print(静态方法中的代码块！--); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); Test.test();静态代码块！--静态方法中的内容! --静态方法中的代码块！-- &#125; final关键字final关键主要用在三个地方：变量，方法，类。 1.修饰变量：如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 2.当用final修饰一个类时：表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 3.final修饰方法时：是把方法锁定，以防任何继承类修改它的含义；类中所有的private方法都隐式地指定为final。]]></content>
      <categories>
        <category>Java学习总结</category>
      </categories>
      <tags>
        <tag>Java基础复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理设计模式]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[静态代理设计模式： 要求： 1.要有真实角色。 2.要有代理角色。 3.两者实现相同的接口，向代理传入真实角色的引用。 4.调用代理的方法。 在Java中线程的设计就使用了静态代理设计模式，其中自定义线程类实现Runable接口，Thread类也实现了Runalbe接口，在创建子线程的时候，传入了自定义线程类的引用，再通过调用start()方法，调用自定义线程对象的run()方法。实现了线程的并发执行。123456789101112131415161718192021public class Test2 &#123; public static void main(String[] args) &#123; //Runnable实现类对象，真实角色 Thread1 role1 = new Thread1(); //线程类代理角色，该类也实现了Runnable接口，代理角色 Thread thread1 = new Thread(role1);//传入了真实角色的引用 thread1.start(); &#125; &#125; class Thread1 implements Runnable &#123; @Override public void run() &#123; //TODO &#125; &#125; Thread对象调用线程的start（）方法，在内部调用了真实角色的run()方法 设计静态代理模式 第一步，要有一个共同使用的接口1234// 共同的接口public interface Proxy &#123; public abstract void todo();&#125; 代理角色和真实角色共同实现该接口,代理角色实现需要的功能。 12345678// 真实角色 class RealityRole implements Proxy &#123; @Override public void todo() &#123; System.out.println(&quot;真实角色的功能&quot;); &#125; &#125; 123456789101112131415161718192021222324252627282930// 代理角色 class ProxyRole implements Proxy &#123; // 持有代理角色的引用 private Proxy realityRole; public ProxyRole() &#123; &#125; //传入一个真实角色 public ProxyRole(Proxy role) &#123; realityRole = role; &#125; @Override public void todo() &#123; //在真实角色功能运行之前，代理角色做准备工作 doBefore(); //执行真实角色的功能 realityRole.todo(); //代理角色的收尾工作 doAfter(); &#125; private void doBefore() &#123; System.out.println(&quot;准备工作&quot;); &#125; private void doAfter() &#123; System.out.println(&quot;收尾工作&quot;); &#125; &#125; 创建真实角色的对象和代理角色的对象，并将真实角色对象的引用传给代理角色，让代理角色去执行功能。 123456789101112 public class Test &#123; public static void main(String[] args) &#123; //创建真实角色对象 Proxy realityRole = new RealityRole(); //创建代理角色对象，并制定真实对象 ProxyRole proxyRole = new ProxyRole(realityRole); //代理角色工作，本质调用的还是真实角色的功能 proxyRole.todo(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理设计模式]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式：一些通用的解决固定问题的方式 增强对象的功能： 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 定义的接口1234567public interface SaleComputer &#123; public String sale(double money); public void show();&#125; 12345678910111213141516/** * 这是真实类 */public class Lenovo implements SaleComputer &#123; @Override public String sale(double money) &#123; System.out.println(&quot;买了一台电脑&quot;+money+&quot;元的联想电脑&quot;); return &quot;联想电脑&quot;; &#125; @Override public void show() &#123; System.out.println(&quot;展示电脑！&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class LenovoProxy &#123; public static void main(String [] args)&#123; //1.创建真实对象 Lenovo lenovo = new Lenovo(); //2.通过动态代理增强Lenovo对象 /* a.类加载器：真实对象.class.getClassLoader(); * b.接口数组：真实对象.class.getInterfaces(); * c.处理器：new InvocationHander()&#123;&#125;; */ // 返回的是一个代理对象，因为代理对象和真是对象实现相同的接口 SaleComputer proxy_lenovo = (SaleComputer) Proxy.newProxyInstance(Lenovo.class.getClassLoader(), Lenovo.class.getInterfaces(), new InvocationHandler() &#123; //代理逻辑编写的方法，代理对象调用的所有方法，都会执行该方法 /* proxy:代理对象 method:代理对象调用的方法，方法会被封装的对象，会被封装到method内 args:代理对象调用方法是实际传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// System.out.println(&quot;该方法被执行了&quot;);// System.out.println(method.getName());// System.out.println(args[0]); //判断是否是sale方法,是就增强 if(method.getName().equals(&quot;sale&quot;))&#123; //1.增强参数 double money = (double)args[0]; money = money*0.85; System.out.println(&quot;专车接........&quot;); Object object = method.invoke(lenovo,money); System.out.println(&quot;专车送货......&quot;); //2.增强返回值 return object+&quot;-------鼠标垫&quot;; &#125;else&#123;//不是sale方法不用增强 //使用真是对象调用该方法 Object object = method.invoke(lenovo,args); //return的返回值就是调用真实增强方法的返回值 return object; &#125; &#125; &#125;); //3.调用方法 String s = proxy_lenovo.sale(8000); System.out.println(s);// proxy_lenovo.show(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Listener学习]]></title>
    <url>%2F2019%2F07%2F18%2FListener%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Listener：监听器概念： web的三大组件之一，web监听器是一种Servlet中的特殊的类，它们能帮助开发者监听web中的特定 事件。比如ServletContext,HttpSession,ServletRequest的创建和销毁；变量的创建、销毁和修改等。 可以在某些动作前后增加处理，实现监控。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 *2 监听器常用的用途 通常使用Web监听器做以下的内容： 统计在线人数，利用HttpSessionLisener 加载初始化信息：利用ServletContextListener 统计网站访问量 实现访问监控 Listener:分类 * ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 12341. web.xml &lt;listener&gt; &lt;listener-class&gt;实现监听器接口的类路径&lt;/listener-class&gt; &lt;/listener&gt; 12345* 指定初始化参数 &lt;context-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/context-param&gt; 2. 注解： * @WebListener]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>监听器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter学习]]></title>
    <url>%2F2019%2F07%2F18%2Ffilter%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Filter：过滤器1. 概念：* 生活中的过滤器：净水器,空气净化器。 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤... 2. 快速入门：1. 步骤： 1. 定义一个类，实现接口Filter 2. 复写方法 3. 配置拦截路径 1. web.xml 2. 注解 1234567891011121314151617181920212223242. 代码： @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filterDemo1被执行了....&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;filterDemo1又被执行了....&quot;); &#125; @Override public void destroy() &#123; &#125; &#125; 3. 过滤器细节：1. web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 过滤器执行流程： 1. 执行过滤器。 2. 执行放行后的资源。 3. 回来执行过滤器放行代码下边的代码。 3. 过滤器生命周期方法 1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时，会执行。执行多次 3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源。 4. 过滤器配置详解 * 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置：资源被访问的方式 * 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源 * web.xml配置 * 设置&lt;h1&gt;&lt;dispatcher&gt;&lt;/dispatcher&gt;&lt;/h1&gt;标签即可。 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题： 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了。 2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml学习]]></title>
    <url>%2F2019%2F07%2F17%2Fxml%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[xml的学习1. 概念：Extensible Markup Language 可扩展标记语言* 可扩展：标签都是自定义的。 例如：&lt;user&gt; &lt;student&gt; * 功能 * 存储数据 1. 配置文件 2. 在网络中传输 * xml与html的区别 1. xml标签都是自定义的，html标签是预定义。 2. xml的语法严格，html语法松散 3. xml是存储数据的，html是展示数据 2. 语法：* 基本语法： 1. xml文档的后缀名 .xml 2. xml第一行必须定义为文档声明 3. xml文档中有且仅有一个根标签 4. 属性值必须使用引号(单双都可)引起来 5. 标签必须正确关闭 6. xml标签名称区分大小写 * 快速入门： 123456789101112131415&lt;?xml version=&apos;1.0&apos; ?&gt;&lt;users&gt; &lt;user id=&apos;1&apos;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id=&apos;2&apos;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; * 组成部分： 1. 文档声明 1. 格式：&lt;?xml 属性列表 ?&gt; 2. 属性列表： * version：版本号，必须的属性 * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 * standalone：是否独立 * 取值： * yes：不依赖其他文件 * no：依赖其他文件 2. 指令(了解)：结合css的 * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 3. 标签：标签名称自定义的 * 规则： * 名称可以包含字母、数字以及其他的字符 * 名称不能以数字或者标点符号开始 * 名称不能以字母 xml（或者 XML、Xml 等等）开始 * 名称不能包含空格 4. 属性： id属性值唯一 5. 文本： * CDATA区：在该区域中的数据会被原样展示 * 格式： &lt;![CDATA[ 数据 ]]&gt; * 约束：规定xml文档的书写规则 * 作为框架的使用者(程序员)： 1. 能够在xml中引入约束文档 2. 能够简单的读懂约束文档 * 分类： 1. DTD:一种简单的约束技术 2. Schema:一种复杂的约束技术 * DTD： * 引入dtd文档到xml文档中 * 内部dtd：将约束规则定义在xml文档中 * 外部dtd：将约束的规则定义在外部的dtd文件中 * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; * Schema: * 引入： 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3.引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot;&gt; 3. 解析：操作xml文档，将文档中的数据读取到内存中* 操作xml文档 1. 解析(读取)：将文档中的数据读取到内存中 2. 写入：将内存中的数据保存到xml文档中。持久化的存储 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;students&gt; &lt;student number=&quot;heima_0001&quot;&gt; &lt;name id=&quot;itcast&quot;&gt; &lt;xing&gt;张&lt;/xing&gt; &lt;ming&gt;三&lt;/ming&gt; &lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=&quot;heima_0002&quot;&gt; &lt;name&gt;jack&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; * 解析xml的方式： 1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 * 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 2. SAX：逐行读取，基于事件驱动的。 * 优点：不占内存。 * 缺点：只能读取，不能增删改 * xml常见的解析器： 1. JAXP：sun公司提供的解析器，支持dom和sax两种思想 2. DOM4J：一款非常优秀的解析器 3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 4. PULL：Android操作系统内置的解析器，sax方式的。 * Jsoup： * 快速入门： * 步骤： 1. 导入jar包 2. 获取Document对象 3. 获取对应的标签Element对象 4. 获取数据 代码： 123456789101112//2.1获取student.xml的pathString path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();//2.2解析xml文档，加载文档进内存，获取dom树---&gt;DocumentDocument document = Jsoup.parse(new File(path), &quot;utf-8&quot;);//3.获取元素对象 ElementElements elements = document.getElementsByTag(&quot;name&quot;);System.out.println(elements.size());//3.1获取第一个name的Element对象Element element = elements.get(0);//3.2获取数据String name = element.text();System.out.println(name); * 对象的使用： 1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse​(File in, String charsetName)：解析xml或html文件的。 * parse​(String html)：解析xml或html字符串 * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 * 获取Element对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 4. Element：元素对象 1. 获取子元素对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 2. 获取属性值 * String attr(String key)：根据属性名称获取属性值 3. 获取文本内容 * String text():获取文本内容 * String html():获取标签体的所有内容(包括字标签的字符串内容) 5. Node：节点对象 * 是Document和Element的父类 * 快捷查询方式： 1. selector:选择器 * 使用的方法：Elements select​(String cssQuery) * 语法：参考Selector类中定义的语法 1234567891011121314151617181920212223242526272829//1.获取student.xml的pathString path = JsoupDemo5.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();//2.获取Document对象Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);//3.查询name标签/* div&#123; &#125; */Elements elements = document.select(&quot;name&quot;);System.out.println(elements);System.out.println(&quot;=----------------&quot;);//4.查询id值为itcast的元素Elements elements1 = document.select(&quot;#itcast&quot;);System.out.println(elements1);System.out.println(&quot;----------------&quot;);//5.获取student标签并且number属性值为heima_0001的age子标签//5.1.获取student标签并且number属性值为heima_0001Elements elements2 = document.select(&quot;student[number=\&quot;heima_0001\&quot;]&quot;);System.out.println(elements2);System.out.println(&quot;----------------&quot;);//5.2获取student标签并且number属性值为heima_0001的age子标签Elements elements3 = document.select(&quot;student[number=\&quot;heima_0001\&quot;] &gt; age&quot;);System.out.println(elements3); 2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 * 使用Jsoup的Xpath需要额外导入jar包。 * 查询w3cshool参考手册，使用xpath的语法完成查询 * 代码： 12345678910111213141516171819202122232425262728293031323334353637//1.获取student.xml的pathString path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();//2.获取Document对象Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);//3.根据document对象，创建JXDocument对象JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询//4.1查询所有student标签List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode);&#125; System.out.println(&quot;--------------------&quot;); //4.2查询所有student标签下的name标签List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode);&#125; System.out.println(&quot;--------------------&quot;); //4.3查询student标签下带有id属性的name标签List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode);&#125;System.out.println(&quot;--------------------&quot;);//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;);for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode);&#125;]]></content>
      <categories>
        <category>xml</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习]]></title>
    <url>%2F2019%2F05%2F13%2Fspring%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Spring学习笔记]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax与json的学习]]></title>
    <url>%2F2019%2F05%2F09%2FAjax%E4%B8%8Ejson%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Ajax和Json的学习Ajax（Asynchronous JavaScript and XML（异步的 JavaScript 和 XML））1. 异步和同步：客户端和服务器端相互通信的基础上 同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 Ajax作用AJAX 是与服务器交换数据并更新部分网页的技术，在不重新加载整个页面的情况下。提升用户的体验。 Ajax的概述AJAX 可以用于创建快速动态的网页。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 使用XHTML作为内容，CSS使用文档对象模型和JavaScript进行动态内容显示。 使用AJAX，当您点击提交时，JavaScript将向服务器发出请求，解释结果并更新当前屏幕。 当客户端程序在后台请求来自服务器的信息时，用户可以继续使用该应用程序。数据驱动而不是页面驱动。 Ajax的原理 使用原声js的Ajax技术 使用原声js的Ajax五大步骤：1.创建Ajax的引擎对象 2.为Ajax引擎绑定监听事件 3.绑定提交地址 4.发送请求 5.接受相应数据 原生的JS实现Ajax方式12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ajax.html&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function but1()&#123; //1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest)&#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else&#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2.绑定监听-----判断服务器数据是否已经返回 xmlHttp.onreadystatechange = function()&#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status==200) &#123; //5.接受响应数据 var date = xmlHttp.responseText; alert(date); &#125; &#125; //3.绑定地址 xmlHttp.open(&quot;GET&quot;,&quot;/Ajax/ajaxServlet&quot;,true);//地址，是否异步 //4.发送请求 xmlHttp.send(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;异步访问服务器&quot; onclick=&quot;but1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ajaxServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getWriter().write(&quot;hello wolrd nihao&quot;);; &#125;&#125; 使用JQuery的Ajax技术1. $.ajax() * 语法：$.ajax({键值对}); 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义方法 function fun() &#123; //使用$.ajax()发送异步请求 $.ajax(&#123; url:&quot;ajaxServlet1111&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(&quot;出错啦...&quot;) &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt; &lt;input&gt;&lt;/body&gt;&lt;/html&gt; 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义方法 function fun() &#123; $.get(&quot;ajaxServlet&quot;,&#123;username:&quot;rose&quot;&#125;,function (data) &#123; alert(data); &#125;,&quot;text&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt; &lt;input&gt;&lt;/body&gt;&lt;/html&gt; 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义方法 function fun() &#123; $.post(&quot;ajaxServlet&quot;,&#123;username:&quot;rose&quot;&#125;,function (data) &#123; alert(data); &#125;,&quot;text&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt; &lt;input&gt;&lt;/body&gt;&lt;/html&gt; Json（JavaScript Object Notation）JSON：JavaScript 对象表示法。 JSON 是轻量级的文本数据交换格式,独立于语言。 JSON是存储和交换文本信息的语法。类似 XML。 JSON比 XML更小、更快 更易解析。 Json的作用对于AJAX应用程序来说，JSON比XML更快更易使用： 使用 XML读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON 读取 JSON 字符串 用 eval() 处理 JSON 字符串 Json的格式与解析JSON 语法： *数据在名称/值对中：json数据是由键值对构成的 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） {&quot;persons&quot;:[{},{}]} 5. 对象（在花括号中） {&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}} 6. null *数据由逗号分隔：多个键值对由逗号分隔 *花括号保存对象：使用{}定义json 格式 *方括号保存数组：[] 定义格式1.定义基本格式 ———&gt; {} 1234var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true&#125;;//获取name的值var name1 = person.name;var name2 = person[&quot;name&quot;]; 2.嵌套格式 ———&gt; [{},{},{}] 12345var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;];//获取李四值alert(ps[1].name)； 3.嵌套格式 ———&gt; {&quot;&quot;:[{},{},{}]} 123456789var persons = &#123; &quot;persons&quot;: [ &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125; ]&#125;;//获取王五值var name1 = persons.persons[2].name; 数据获取1. json对象.键名 2. json对象[&quot;键名&quot;] 3. 数组对象[索引] 4. 遍历 遍历获取person对象中所有的键和值(for in 循环) 123456var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true&#125;;for(var key in person)&#123; //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]);&#125; 遍历获取ps中的所有值 123456789var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;];for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+&quot;:&quot;+p[key]); &#125;&#125; JSON数据和Java对象的相互转换* JSON解析器： * 常见的解析器：Jsonlib，Gson，fastjson，jackson 1. JSON转为Java对象1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. readValue(json字符串数据,Class) JSON字符串转为Java对象123456789101112@Testpublic void test5() throws Exception &#123; //1.初始化JSON字符串 String json = &quot;&#123;\&quot;gender\&quot;:\&quot;男\&quot;,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:23&#125;&quot;; //2.创建ObjectMapper对象 ObjectMapper mapper = new ObjectMapper(); //3.转换为Java对象 Person对象 Person person = mapper.readValue(json, Person.class); System.out.println(person);&#125; 2. Java对象转换JSON1. 使用步骤： 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串 2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致 Java对象转为JSON字符串 1234567891011121314151617181920@Testpublic void test1() throws Exception &#123; //1.创建Person对象 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); //2.创建Jackson的核心对象 ObjectMapper ObjectMapper mapper = new ObjectMapper(); //3.转换 String json = mapper.writeValueAsString(p); //System.out.println(json);//&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125; //writeValue，将数据写到d://a.txt文件中 //mapper.writeValue(new File(&quot;d://a.txt&quot;),p); //writeValue.将数据关联到Writer中 mapper.writeValue(new FileWriter(&quot;d://b.txt&quot;),p);&#125; 注解 123456789101112131415161718192021222324252627282930public class Person &#123; private String name; private int age ; private String gender; //@JsonIgnore // 忽略该属性 @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)//属性值得格式化 private Date birthday; //省略的get和set方法&#125;@Testpublic void test2() throws Exception &#123; //1.创建Person对象 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); p.setBirthday(new Date()); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(p); System.out.println(json); //&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:1530958029263&#125; //&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;&#125; 复杂java对象转换——List：数组 123456789101112131415161718192021222324252627282930313233343536373839404142 @Test public void test3() throws Exception &#123; //1.创建Person对象 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); p.setBirthday(new Date()); Person p1 = new Person(); p1.setName(&quot;张三&quot;); p1.setAge(23); p1.setGender(&quot;男&quot;); p1.setBirthday(new Date()); Person p2 = new Person(); p2.setName(&quot;张三&quot;); p2.setAge(23); p2.setGender(&quot;男&quot;); p2.setBirthday(new Date()); //1.创建List集合 List&lt;Person&gt; ps = new ArrayList&lt;Person&gt;(); ps.add(p); ps.add(p1); ps.add(p2); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(ps); // [&#123;&#125;,&#123;&#125;,&#123;&#125;] //[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;, &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;, &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;] System.out.println(json); &#125;``` - 复杂java对象转换------Map:对象格式一致 @Test public void test4() throws Exception { //1.创建map对象 Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put(&quot;name&quot;,&quot;张三&quot;); map.put(&quot;age&quot;,23); map.put(&quot;gender&quot;,&quot;男&quot;); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(map); System.out.println(json);//{&quot;gender&quot;:&quot;男&quot;,&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23} } `]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑hexo]]></title>
    <url>%2F2018%2F05%2F08%2F%E7%BC%96%E8%BE%91hexo%2F</url>
    <content type="text"><![CDATA[一级标题如何使用hexo编辑文章（二级标题）创建一个文章(heox n “文章名”)（三级标题） 字体是斜的 字体加粗字体 列表1 子列表a 子列表b 子列表c 子列表d 列表2 子列表a 子列表b 子列表c 子列表d 列表3 子列表a 子列表b 子列表c 子列表d JavaGuide学习-导航技术面试必备知识-导航 &lt;h1&gt;单行代码&lt;/h1&gt; 1234567public class Test &#123; public static void main(String []args)&#123; System.out.println(&quot;hello world&quot;); &#125;&#125; 我的是引用的]]></content>
      <categories>
        <category>编辑文章</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客文章]]></title>
    <url>%2F2017%2F05%2F07%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[关于hexo的安装与Github部署前言使用github pages服务搭建博客的好处有： 1.全是静态文件，访问速度快； 2.免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3.可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5.博客内容可以轻松打包、转移、发布到其它平台； 6.等等； 1.准备工作 ·有一个GitHub账号 ·安装了，git、node.js了解相关知识 2.创建仓库 新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 1.注册的邮箱一定要验证，否则不会成功； 2.仓库名字必须是：username.github.io，其中username是你的用户名； 3.仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 3.绑定域名 配置SSH key 为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 &lt;h1&gt;$ cd ~/. ssh #检查本机已存在的ssh密钥&lt;/h1&gt; 如果提示：No such file or directory 说明你是第一次使用git。 &lt;h1&gt;ssh-keygen -t rsa -C &quot;邮件地址&quot;&lt;/h1&gt; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 1.检测是否配置成功 使用hexo编写博客1.hexo简介 2.原理 3.注意事项 4.安装 5.初始化 6.修改主题 7.上传之前 8.上传到Github 9.保留CNAME、README.md等文件 10._config.yml 11.如何写博客 11.1写博客工具 11.2如何让博文列表不显示全部内容 hexo的常用命令1.常见命令() hexo n(new) &quot;postName&quot; #创建文章 hexo n(new) page &quot;pageName&quot; #创建页面 hexo g(generate) #生成静态页面之public目录 hexo s(server) #开启预访问端口(默认4000，&apos;ctrl+c&apos;关闭server) hexo d(deploy) #部署到Github hexo help #查看帮助 hexo v(version) #查看hexo版本 hexo clean #清理缓存 2.组合命令： hexo s -g #生成并本地浏览 hexo d -g #生成并上传 3.修改配置文件或修改创建博客命令行： a.hexo clean b.hexo g c.hexo d 参考文献https://dxd1392979164.github.io]]></content>
      <categories>
        <category>hexo安装</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2010%2F09%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. dxd的博客Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello world</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
</search>
