<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式什么是单例设计模式？ 通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。并且自行实例化向整个系统提供。 懒汉式需要： （1）将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 （2）在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。 （3）定义一个静态方法返回这个唯一对象。 12345678910111213public class Monitor &#123; private static Monitor monitor = null; private Monitor() &#123;&#125; public static Monitor getMonitor() &#123; if(monitor == null) &#123; monitor = new Monitor(); &#125; return monitor; &#125;&#125; 优点：实现起来比较简单，当类Monitor被加载的时候，静态变量static的monitor未被创建并分配内存空间，当getMonitor方法第一次被调用时，初始化monitor变量，并分配内存，因此在某些特定条件下会节约了内存。 缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态。上述代码还是不能保证一个班长实例的，因为存在线程安全问题。假如线程A执行到了monitor = new Monitor();，此时班长对象还没创建，线程B执行到判断 monitor == null时，条件为true，于是也进入到if里面去执行monitor = new Monitor();了，这样内存中就出现了两个班长实例了。 线程安全的懒汉模式12345678910111213public class Monitor &#123; private static Monitor monitor = null; private Monitor() &#123;&#125; // 静态方法返回该实例，加synchronized关键字实现同步 public static synchronized Monitor getMonitor() &#123; if (monitor == null) &#123; monitor = new Monitor(); &#125; return monitor; &#125;&#125; 优点：在多线程情形下，保证了“懒汉模式”的线程安全。 缺点：多线程情形下，synchronized方法通常效率低。 12345678910public static Monitor getMonitor() &#123; if (monitor == null) &#123; synchronized (Monitor.class) &#123; if (monitor == null) &#123; monitor = new Monitor(); &#125; &#125; &#125; return monitor;&#125; 第一层判断如果 monitor 实例不为空，那皆大欢喜，说明对象已经被创建过了，直接返回该对象即可，不会走到 synchronized 部分，所以班长对象被创建了之后，不会影响到性能。第二层判断是在 synchronized 代码块里面，为什么要再做一次判断呢？假如 monitor 对象是 null，那么第一层判断后，肯定有很多线程已经进来第一层了，那么即使在第二层某个线程执行完了之后，释放了锁，其他线程还会进入synchronized代码块，如果不判断，那么又会被创建一次，这就导致了多个班长对象的创建。所以第二层起到了一个防范作用。 饿汉式12345678910public class Monitor &#123; private static final Monitor monitor = new Monitor(); private Monitor() &#123;&#125; public static Monitor getMonitor() &#123; return monitor; &#125;&#125; 优点：实现起来简单，没有多线程同步问题。缺点：当类Monitor 被加载的时候，会初始化static的monitor，静态变量被创建并分配内存空间，从这以后，这个static的monitor对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。 饿汉式(静态代码块模式)1234567891011public class Monitor &#123; private static final Monitor monitor = null; static &#123; monitor = new Monitor(); &#125; private Monitor() &#123; &#125; public static final Monitor getInstance() &#123; return monitor; &#125;&#125; 这种静态代码块模式，本质上是饿汉模式的一个变种。 静态内部类班长这个对象有个属性是不会变的，那就是他所在的班级，所以班级可以直接定义好。如果想获取CLASS_INFO， 可以通过Monitor.CLASS_INFO,但是但是这样获取的话，因为都是static修饰的，调用Monitor.CLASS_INFO时， 也会执行构造方法将monitor对象初始化，但是我现在不想初始化班长对象（因为会影响性能） 12345678public class Monitor &#123; public static String CLASS_INFO = &quot;通信工程（1）班&quot;; private static Monitor monitor = new Monitor (); private Monitor () &#123;&#125; public static Monitor getMonitor() &#123; return monitor; &#125;&#125; 12345678910111213public class Monitor &#123; public static String CLASS_INFO = &quot;通信工程（1）班&quot;; /** * 静态内部类，用来创建班长对象 */ private static class MonitorCreator &#123; private static Monitor monitor = new Monitor(); &#125; private Monitor() &#123;&#125; public static Monitor getInstance() &#123; return MonitorCreator.monitor; &#125;&#125; 当执行getInstance()方法的时候会去调用内部类MoninorCreator里面的monitor的实例，此时MonitorCreator会 被加载、到内存，在类加载的时候对Monit实例进行初始化。而且当我使用Monitor.CLASS_INFO获取信息时，也不会对 monitor进行初始化。还确保了线程安全，因为JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线 程互斥的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F03%2F8%E6%9C%883%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java学习总结</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2019%2F07%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[一、计算机网络体系结构 1.1 应用层 应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议。应用层交互的数据单元称为报文。 域名系统 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 HTTP协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。 1.2 运输层 运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。 运输层主要使用以下两种协议: 传输控制协议 TCP（Transmission Control Protocol）–提供面向连接的，可靠的数据传输服务。用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。 1.3 网络层 在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此 分组也叫IP 数据报，简称 数据报。 1.4 数据链路层 数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。 1.5 物理层 在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 二、TCP 三次握手和四次挥手为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。 2.1 TCP 三次握手漫画图解 客户端–发送带有 SYN 标志的数据包–一次握手–服务端服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端 2.2 为什么要三次握手 三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。 2.3 为什么要传回 SYN 接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。 SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement（确认字符 ）,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。 2.4 传了 SYN,为啥还要传 ACK 双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。 2.5 四次挥手 断开一个 TCP 连接则需要“四次挥手”： 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号服务器-关闭与客户端的连接，发送一个FIN给客户端客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1 2.6 为什么要四次挥手 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 三、TCP,UDP 协议的区别UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信）如：QQ 语音、 QQ 视频。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。 四、TCP 协议如何保证可靠传输 1.应用数据被分割成 TCP 认为最适合发送的数据块。2.TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。3.校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。4.TCP 的接收端会丢弃重复的数据。5.流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）6.拥塞控制： 当网络拥塞时，减少数据的发送。A7.RQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。8.超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring bean的作用域]]></title>
    <url>%2F2019%2F07%2F27%2FSpring%20bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Spring学习笔记##一 bean的作用域 五种作用域中，request、session 和 global session 三种作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于 web 的 Spring ApplicationContext 环境。 1. singleton——唯一 bean 实例 当一个 bean 的作用域为 singleton，那么Spring IoC容器中只会存在一个共享的 bean 实例，并且所有对 bean 的请求，只要 id 与该 bean 定义相匹配，则只会返回bean的同一实例。singleton 是单例类型(对应于单例模式)，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，但我们可以指定Bean节点的 lazy-init=”true” 来延迟初始化bean，这时候，只有在第一次获取bean时才会初始化bean，即第一次请求该bean时才初始化。 每次获取到的对象都是同一个对象。 &lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt; 也可以通过 @Scope 注解（它可以显示指定bean的作用范围。）的方式 12345@Service@Scope(&quot;singleton&quot;)public class ServiceImpl&#123;&#125; 2. prototype——每次请求都会创建一个新的 bean 实例 当一个bean的作用域为 prototype，表示一个 bean 定义对应多个对象实例。 prototype 作用域的 bean 会导致在每次对该 bean 请求（将其注入到另一个 bean 中，或者以程序的方式调用容器的 getBean() 方法）时都会创建一个新的 bean 实例。prototype 是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的 bean 应该使用 prototype 作用域，而对无状态的 bean 则应该使用 singleton 作用域。 123&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt; 或者&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt; 12345@Service@Scope(&quot;prototype&quot;)public class ServiceImpl&#123;&#125; 3. request——每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效 request只适用于Web程序，每一次 HTTP 请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，当请求结束后，该对象的生命周期即告结束。 &lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt; 4. session——每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效 session只适用于Web程序，session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效.与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的 HTTP session 中根据 userPreferences 创建的实例，将不会看到这些特定于某个 HTTP session 的状态变化。当HTTP session最终被废弃的时候，在该HTTP session作用域内的bean也会被废弃掉。 &lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt; 5. globalSession global session 作用域类似于标准的 HTTP session 作用域，不过仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portle t所共享。在global session 作用域中定义的 bean 被限定于全局portlet Session的生命周期范围内。 &lt;bean id=&quot;user&quot; class=&quot;com.foo.Preferences &quot;scope=&quot;globalSession&quot;/&gt; ##二 bean的生命周期 initialization 和 destroy 有时我们需要在Bean属性值set好之后和Bean销毁之前做一些事情，比如检查Bean中某个属性是否被正常的设置好值了。Spring框架提供了多种方法让我们可以在Spring Bean的生命周期中执行initialization和pre-destroy方法。 1.实现InitializingBean和DisposableBean接口 这两个接口都只包含一个方法。通过实现InitializingBean接口的afterPropertiesSet()方法可以在Bean属性值设置好之后做一些操作，实现DisposableBean接口的destroy()方法可以在销毁Bean之前做一些操作。 例子：1234567891011public class GiraffeService implements InitializingBean,DisposableBean &#123; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;执行InitializingBean接口的afterPropertiesSet方法&quot;); &#125; @Override public void destroy() throws Exception &#123; System.out.println(&quot;执行DisposableBean接口的destroy方法&quot;); &#125;&#125; 这种方法比较简单，但是不建议使用。因为这样会将Bean的实现和Spring框架耦合在一起。 2.在bean的配置文件中指定init-method和destroy-method方法 Spring允许我们创建自己的 init 方法和 destroy 方法，只要在 Bean 的配置文件中指定 init-method 和 destroy-method 的值就可以在 Bean 初始化时和销毁之前执行一些操作。 例子：1234567891011public class GiraffeService &#123; //通过&lt;bean&gt;的destroy-method属性指定的销毁方法 public void destroyMethod() throws Exception &#123; System.out.println(&quot;执行配置的destroy-method&quot;); &#125; //通过&lt;bean&gt;的init-method属性指定的初始化方法 public void initMethod() throws Exception &#123; System.out.println(&quot;执行配置的init-method&quot;); &#125;&#125; 配置文件中的配置： name1&lt;/bean&gt; 注意的是自定义的init-method和post-method方法可以抛异常但是不能有参数。 3.使用@PostConstruct和@PreDestroy注解 除了xml配置的方式，Spring 也支持用 @PostConstruct和 @PreDestroy注解来指定 init 和 destroy 方法。这两个注解均在javax.annotation 包中。为了注解可以生效，需要在配置文件中定义: 例子：12345678910public class GiraffeService &#123; @PostConstruct public void initPostConstruct()&#123; System.out.println(&quot;执行PostConstruct注解标注的方法&quot;); &#125; @PreDestroy public void preDestroy()&#123; System.out.println(&quot;执行preDestroy注解标注的方法&quot;); &#125;&#125; 配置文件： &lt;bean class=&quot;org.springframework.context.annotation.CommonAnnotationBeanPostProcessor&quot; /&gt; 总结：Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁。而对于 prototype 作用域的bean，Spring只负责创建，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring容器将不再跟踪其生命周期，并且不会管理那些被配置成prototype作用域的bean的生命周期。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发总结]]></title>
    <url>%2F2019%2F07%2F26%2FJava%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java并发总结1. 什么是线程和进程? 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 1.2. 何为线程? 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 2.1. 图解进程和线程的关系 JVM 的角度来说一下线程和进程之间的关系 一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。 总结：线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。 2.2. 程序计数器为什么是私有的? 程序计数器主要有下面两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。 所以程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。 2.3. 虚拟机栈和本地方法栈为什么是私有的? 虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。 2.4. 一句话简单了解堆和方法区 堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 3. 说说并发与并行的区别? 并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；并行： 单位时间内，多个任务同时执行。 4. 为什么要使用多线程呢? 1.线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。2.多线程并发编程正是开发高并发系统的基础。3.单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率4.多核时代: 多核时代多线程主要是为了提高 CPU 利用率 5.线程的生命周期和状态? 6. 什么是上下文切换? 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 8. 什么是线程死锁?如何避免死锁? 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。 产生死锁必须具备以下四个条件： 1.互斥条件：该资源任意一个时刻只由一个线程占用。2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。3.不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 8.1. 如何避免线程死锁? 我们只要破坏产生死锁的四个条件中的其中一个就可以了。 破坏互斥条件 这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。 破坏请求与保持条件 一次性申请所有的资源。 破坏不剥夺条件 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 9.sleep() 方法和 wait() 方法区别和共同点? 两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。两者都可以暂停线程的执行。Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？ new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类和常量池]]></title>
    <url>%2F2019%2F07%2F24%2FString%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[String 类和常量池1.1 String 对象的两种创建方式： 12345String str1 = &quot;abcd&quot;;String str2 = new String(&quot;abcd&quot;);//堆中创建一个新的对象String str3 = new String(&quot;abcd&quot;);//堆中创建一个新的对象System.out.println(str1==str2);//falseSystem.out.println(str2==str3);//false String str1 = &quot;abcd&quot;;//先检查字符串常量池中有没有”abcd”，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向”abcd””； 这两种不同的创建方法是有差别的。 第一种方式是在常量池中拿对象； 第二种方式是直接在堆内存空间创建一个新的对象。 注意：只要使用 new 方法，便需要创建新的对象。 1.2 String 类型的常量池比较特殊。它的主要使用方法有两种： ①直接使用双引号声明出来的 String 对象会直接存储在常量池中。 ②如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。 123456String s1 = new String(&quot;计算机&quot;);String s2 = s1.intern();String s3 = &quot;计算机&quot;;System.out.println(s2);//计算机System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象 1.3 字符串拼接:123456789String str1 = &quot;str&quot;;String str2 = &quot;ing&quot;;String str3 = &quot;str&quot; + &quot;ing&quot;;//常量池中的对象String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = &quot;string&quot;;//常量池中的对象System.out.println(str3 == str4);//falseSystem.out.println(str3 == str5);//trueSystem.out.println(str4 == str5);//false 使用String（不可改变，因为使用了final修饰字符数组来保存字符串）尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder（线程安全，可以改变）或者 StringBuffer（线程不安全，可以改变）。 1.4 String s1 = new String(“abc”);这句话创建了几个字符串对象？ 将创建 1 或 2 个字符串。如果池中已存在字符串文字“abc”，则池中只会创建一个字符串“s1”。如果池中没有字符串文字“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。 1234String s1 = new String(&quot;abc&quot;);// 堆内存的地址值String s2 = &quot;abc&quot;;System.out.println(s1 == s2);//（比地址） 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。System.out.println(s1.equals(s2));//（比内容） 输出 true 1.5 8 种基本类型的包装类和常量池 Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long；这4种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。Boolean:true,false 123456789Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueInteger i11 = 333;Integer i22 = 333;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。Integer i1 = new Integer(40);这种情况下会创建新的对象。 Integer 缓存源代码：12345678/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/ public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; Character 缓存源代码：123456public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125; 例子： 12345678910111213Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println(&quot;i1=i2 &quot; + (i1 == i2));System.out.println(&quot;i1=i2+i3 &quot; + (i1 == i2 + i3));System.out.println(&quot;i1=i4 &quot; + (i1 == i4));System.out.println(&quot;i4=i5 &quot; + (i4 == i5));System.out.println(&quot;i4=i5+i6 &quot; + (i4 == i5 + i6)); System.out.println(&quot;40=i5+i6 &quot; + (40 == i5 + i6)); 结果：123456i1=i2 truei1=i2+i3 truei1=i4 falsei4=i5 falsei4=i5+i6 true40=i5+i6 true 语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域]]></title>
    <url>%2F2019%2F07%2F23%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java 内存区域一、运行时数据区域JDK 1.8 之前： JDK 1.8 之后： 2.1.程序计数器 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 2.2 Java 虚拟机栈 与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。） 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用 Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。 StackOverFlowError（栈溢出）：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。OutOfMemoryError（内存溢出）：若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。 那么方法/函数如何调用？ Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。 Java 方法有两种返回方式： return 语句。抛出异常。不管哪种返回方式都会导致栈帧被弹出。 2.3 本地方法栈 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。 2.4 堆 Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法（其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。），所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。 上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 2.5 方法区 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 方法区也被称为永久代。 2.5.1 方法区和永久代的关系 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。 与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。 2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢? HotSpot 虚拟机把方法区当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 2.6 运行时常量池 运行时常量池是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 2.7 直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。 JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 二、HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。 3.1 对象的创建 Step1:类加载检查 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 Step1:分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 内存分配的两种方式： 内存分配并发问题： 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全： CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 Step1:初始化零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 Step1:设置对象头 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 Step1:执行init方法 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始， 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 3.2 对象的内存布局（对象在内存中的存储）在 Hotspot 虚拟机中,对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。 Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的自身运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 3.3 对象的访问定位 建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有①使用句柄和②直接指针两种： ①句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息； ②直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F07%2F22%2FRedis%2F</url>
    <content type="text"><![CDATA[Redis1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库。1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1.NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2.非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3.关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4.总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据。 1.2 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.2.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 2. 下载安装1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 4. 持久化1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 5. Java客户端 Jedis* Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string 123456789101112131415//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 12345678910111213141516171819202122232425//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) &#123; //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); &#125; //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 1234567891011121314151617181920212223242526//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 1234567891011121314//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 1234567891011121314151617//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 123456789101112131415//0.创建一个配置对象JedisPoolConfig config = new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdle(10); //1.创建Jedis连接池对象JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接Jedis jedis = jedisPool.getResource();//3. 使用jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中jedis.close(); * 连接池工具类 12345678910111213141516171819202122232425262728293031public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;]]></content>
      <categories>
        <category>工具和中间件</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的四种内部类]]></title>
    <url>%2F2019%2F07%2F21%2FJava%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java四种内部类因为之前复习到staic关键字，因为static修饰类只能修饰内部类，所以就对内部类进行了复习，所以写下这篇博客。 成员内部类成员内部类是最普通的内部类，它的定义为位于另一个类的内部。 一般格式如下,因为类C相对与类D在外面，我们且称类C为外部类。 12345class C&#123; class D&#123; &#125;&#125; 成员内部类的特性： 1.内部类可以无条件访问外部类的属性和方法（包括private成员和静态成员）。123456789101112131415161718192021class C &#123; private String name = &quot;外部类&quot;; private static String staticName = &quot;外部类的静态成员&quot;; public void run() &#123; System.out.println(&quot;外部类奔跑&quot;); &#125; public static void staticRun() &#123; System.out.println(&quot;外部类的静态方法&quot;); &#125; class D &#123; public void say() &#123; System.out.println(name); System.out.println(staticName); run(); staticRun(); &#125; &#125;&#125; 2.外部类想要访问内部类的属性和方法时就必须通过内部类的对象，通过对象访问。 123456789101112131415161718192021222324class C &#123; private String name = &quot;外部类&quot;; private static String staticName = &quot;外部类的静态成员&quot;; public void run() &#123; System.out.println(&quot;外部类奔跑&quot;); &#125; public static void staticRun() &#123; System.out.println(&quot;外部类的静态方法&quot;); &#125; public void test() &#123; D d = new D(); d.say(); &#125; class D &#123; public void say() &#123; System.out.println(name); System.out.println(staticName); run(); staticRun(); &#125; &#125;&#125; 3.如果成员内部类的属性或者方法与外部类的同名，将导致外部类的这些属性与方法在内部类被隐藏，需要按照该格式调用。 12外部类.this.成员变量外部类.this.成员方法 4.那如何创建一个内部类对象了? 前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125; class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 5.内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及默认访问权限。外部类只能被 public和包访问两种权限修饰。由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 格式如下： 12345678class A &#123; public void testA() &#123; class B &#123;// 局部内部类 &#125; &#125;&#125; 注意: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。 匿名内部类1.匿名内部类也就是没有名字的内部类正因为没有名字。 2.所以匿名内部类只能使用一次，它通常用来简化代码编写。 3.但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。 1234567891011121314151617181920public class Demo3 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub driveCar(new Car() &#123; @Override public void drive() &#123; System.out.println(&quot;驾驶着汽车&quot;); &#125; &#125;); &#125; public static void driveCar(Car car) &#123; car.drive(); &#125;&#125;interface Car &#123; void drive();&#125; 注意： 匿名内部类不能定义任何静态成员、方法。 匿名内部类中的方法不能是抽象的； 匿名内部类必须实现接口或抽象父类的所有抽象方法。 匿名内部类访问的外部类成员变量或成员方法必须用static修饰； 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。这个内部类就属于外部类本身，而不属于外部类的某个对象。 1234567891011121314151617public class Demo4 &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125;class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 注意： 1.非静态内部类中不允许定义静态成员 2.静态内部类不能使用外部类的非static成员变量或者方法]]></content>
      <categories>
        <category>Java学习总结</category>
      </categories>
      <tags>
        <tag>Java基础复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F07%2F21%2FMySQL%2F</url>
    <content type="text"><![CDATA[如何查看mysql的安装路径：在命令窗口中输入mysql命令时，提示“mysql不是内部命令也不是可运行的程序”，发现此问题是由于系统的环境变量中未配置MySQL安装目录可执行文件的路径，可是安装MySQL时是默认按照的，此时已经忘记了安装位置，各个盘符中找了一遍，都没有找到。那么要怎样找到其安装的路径呢？ 1.使用MySQL客户端查询 select @@basedir as basePath from dual 2.只需登录MySQL的客户端 输入命令：show variables like “%char%”; 存储引擎 查看MySQL提供的所有存储引擎 show engines; MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。 MyISAM和InnoDB区别： MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。 两者的对比： 1.是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。2.是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。3.是否支持外键： MyISAM不支持，而InnoDB支持。4.是否支持MVCC（多版本并发控制） ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。 索引 MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。 MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。 MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。 InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 什么是事务?事务是逻辑上的一组操作，要么都执行，要么都不执行。 事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。 事物的四大特性(ACID)：原子性，一致性，隔离性，持久性。 1.原子性（atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；2.一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；3.隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；4.持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 并发事务带来哪些问题? 1.脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 2.丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 3.不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 4.幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 不可重复度和幻读区别： 不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。 事务隔离级别有哪些?MySQL的默认隔离级别是? SQL 标准定义了四个隔离级别： 1.READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。2.READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。3.REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。4.SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 ！图片 MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看 这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。 InnoDB 存储引擎在 分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java关键字]]></title>
    <url>%2F2019%2F07%2F20%2FJava%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[this关键字this关键字用于引用当前类实例。当一个对象创建后，Java虚拟机会为这个对象分配一个自身引用的指针，这个指针就是this。 a.使用this调用当前实例的变量。 b.使用this调用当前实例的方法（this可以省略） c.this调用本类中的其他构造方法，调用时要放在构造方法的首行。 d.this还可以返回类的引用。return this来返回某个类对象。 123456789101112131415161718public class Test32 &#123; private int number; public void changeNumber(int number) &#123; System.out.println(&quot;局部变量的number值为：&quot; + (number + 5)); System.out.println(&quot;成员变量的number值为：&quot; + (this.number + 2)); &#125; @Test public void test() &#123; int inputNum = 2; changeNumber(inputNum); &#125;&#125; 123456789101112131415161718public class Test32 &#123; private int number; public void changeNumber(int number) &#123; System.out.println(&quot;局部变量的number值为：&quot; + (number + 5)); System.out.println(&quot;成员变量的number值为：&quot; + (this.number + 2)); &#125; @Test public void test() &#123; int inputNum = 2; this.changeNumber(inputNum); &#125;&#125; 注意： 1.this调用构造方法必须放在首行。 2.this不能用在staic方法中，因为staic方法优先与对象存在。（static是在类加载的时候） 3.如果实例变量和局部变量重名时，Java会先按照局部变量，后实例变量去寻找，如果都找不到，则编译错误，如果使用this.a,则直接去实例变量中找； super关键字作用： 1.在子类中访问父类的的变量和方法。1234567891011121314public class Super &#123; protected int number; protected showNumber() &#123; System.out.println(&quot;number = &quot; + number); &#125;&#125; public class Sub extends Super &#123; void bar() &#123; super.number = 10; super.showNumber(); &#125;&#125; 在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。 2.在子类中访问父类的构造方法。如果子类没用通过super(参数列表)调用父类的构造方法，则会自动默认调用父类的无参构造方法，如果父类没用无参构造方法，此时会报错。 12345678910111213141516171819202122232425262728293031class Father &#123; int age ; public Father()&#123; &#125; public Father(int age) &#123; this.age = age; &#125; public void sayFather() &#123; System.out.println(age); &#125;&#125;class Son extends Father &#123; public String name; public Son() &#123; super();//不写默认调用 &#125; public Son(String name) &#123; super(25); this.name = name; &#125; public String say() &#123; super.sayFather(); System.out.println(super.age); return this.name; &#125;&#125; 注意： 1.访问父类的构造方法时必须放在首行，不写默认调用父类无参构造。 使用 this 和 super 要注意的问题： 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。this、super不能用在static方法中。 static关键字static关键字主要用在三个地方：方法，变量，静态代码块，类，静态导包； 1.修饰成员变量和成员方法：使用static修饰的方法或变量是属于类，不属于单个对象，是所有对象共享的。并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()。 2.静态代码块：静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次。非静态代码块没new一次就会执行一次。非静态代码块是给所有对象进行初始化。构造方法是给对应的对象进行初始化。 3.静态内部类（static修饰的类只能是静态内部类）：静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 4.静态导包(用来导入类中的静态资源，1.5之后的新特性):格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 static详解修饰成员变量和成员方法(常用) 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 调用格式： 类名.静态变量名 类名.静态方法名() 测试方法：1234567891011121314151617181920public class StaticBean &#123; String name; 静态变量 static int age; public StaticBean(String name) &#123; this.name = name; &#125; 静态方法 static void SayHello() &#123; System.out.println(Hello i am java); &#125; @Override public String toString() &#123; return StaticBean&#123; + name=&apos; + name + &apos;&apos;&apos; + age + age + &apos;&#125;&apos;; &#125;&#125; 1234567891011121314public class StaticDemo &#123; public static void main(String[] args) &#123; StaticBean staticBean = new StaticBean(1); StaticBean staticBean2 = new StaticBean(2); StaticBean staticBean3 = new StaticBean(3); StaticBean staticBean4 = new StaticBean(4); StaticBean.age = 33; System.out.println(staticBean+ +staticBean2+ +staticBean3+ +staticBean4); //结果taticBean&#123;name=&apos;1&apos;age33&#125; StaticBean&#123;name=&apos;2&apos;age33&#125; StaticBean&#123;name=&apos;3&apos;age33&#125; StaticBean&#123;name=&apos;4&apos;age33&#125; StaticBean.SayHello();Hello i am java &#125;&#125; 静态代码块 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态代码块的格式是 static {语句体;} 一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 注意：静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。123456789public class Demo2 &#123; static &#123; a = 10; System.out.println(a);//这里会报错，不能访问 &#125; private static int a ;&#125; 静态内部类静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖外围类的创建。它不能使用任何外围类的非static成员变量和方法。 Example（静态内部类实现单例模式）123456789101112131415public class Singleton &#123; 声明为 private 避免调用默认构造方法创建对象 private Singleton() &#123; &#125; 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问 private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。 静态导包 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法 static方法与非static方法静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。 总结：在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 static{}静态代码块与{}非静态代码块(构造代码块) 相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 1234567891011121314151617181920212223242526public class Test &#123; public Test() &#123; System.out.print(默认构造方法！--); &#125; 非静态代码块 &#123; System.out.print(非静态代码块！--); &#125; 静态代码块 static &#123; System.out.print(静态代码块！--); &#125; public static void test() &#123; System.out.print(静态方法中的内容! --); &#123; System.out.print(静态方法中的代码块！--); &#125; &#125; public static void main(String[] args) &#123; Test test = new Test(); Test.test();静态代码块！--静态方法中的内容! --静态方法中的代码块！-- &#125; final关键字final关键主要用在三个地方：变量，方法，类。 1.修饰变量：如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 2.当用final修饰一个类时：表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 3.final修饰方法时：是把方法锁定，以防任何继承类修改它的含义；类中所有的private方法都隐式地指定为final。]]></content>
      <categories>
        <category>Java学习总结</category>
      </categories>
      <tags>
        <tag>Java基础复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理设计模式]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[静态代理设计模式： 要求： 1.要有真实角色。 2.要有代理角色。 3.两者实现相同的接口，向代理传入真实角色的引用。 4.调用代理的方法。 在Java中线程的设计就使用了静态代理设计模式，其中自定义线程类实现Runable接口，Thread类也实现了Runalbe接口，在创建子线程的时候，传入了自定义线程类的引用，再通过调用start()方法，调用自定义线程对象的run()方法。实现了线程的并发执行。123456789101112131415161718192021public class Test2 &#123; public static void main(String[] args) &#123; //Runnable实现类对象，真实角色 Thread1 role1 = new Thread1(); //线程类代理角色，该类也实现了Runnable接口，代理角色 Thread thread1 = new Thread(role1);//传入了真实角色的引用 thread1.start(); &#125; &#125; class Thread1 implements Runnable &#123; @Override public void run() &#123; //TODO &#125; &#125; Thread对象调用线程的start（）方法，在内部调用了真实角色的run()方法 设计静态代理模式 第一步，要有一个共同使用的接口1234// 共同的接口public interface Proxy &#123; public abstract void todo();&#125; 代理角色和真实角色共同实现该接口,代理角色实现需要的功能。 12345678// 真实角色 class RealityRole implements Proxy &#123; @Override public void todo() &#123; System.out.println(&quot;真实角色的功能&quot;); &#125; &#125; 123456789101112131415161718192021222324252627282930// 代理角色 class ProxyRole implements Proxy &#123; // 持有代理角色的引用 private Proxy realityRole; public ProxyRole() &#123; &#125; //传入一个真实角色 public ProxyRole(Proxy role) &#123; realityRole = role; &#125; @Override public void todo() &#123; //在真实角色功能运行之前，代理角色做准备工作 doBefore(); //执行真实角色的功能 realityRole.todo(); //代理角色的收尾工作 doAfter(); &#125; private void doBefore() &#123; System.out.println(&quot;准备工作&quot;); &#125; private void doAfter() &#123; System.out.println(&quot;收尾工作&quot;); &#125; &#125; 创建真实角色的对象和代理角色的对象，并将真实角色对象的引用传给代理角色，让代理角色去执行功能。 123456789101112 public class Test &#123; public static void main(String[] args) &#123; //创建真实角色对象 Proxy realityRole = new RealityRole(); //创建代理角色对象，并制定真实对象 ProxyRole proxyRole = new ProxyRole(realityRole); //代理角色工作，本质调用的还是真实角色的功能 proxyRole.todo(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理设计模式]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式：一些通用的解决固定问题的方式 增强对象的功能： 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 定义的接口1234567public interface SaleComputer &#123; public String sale(double money); public void show();&#125; 12345678910111213141516/** * 这是真实类 */public class Lenovo implements SaleComputer &#123; @Override public String sale(double money) &#123; System.out.println(&quot;买了一台电脑&quot;+money+&quot;元的联想电脑&quot;); return &quot;联想电脑&quot;; &#125; @Override public void show() &#123; System.out.println(&quot;展示电脑！&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class LenovoProxy &#123; public static void main(String [] args)&#123; //1.创建真实对象 Lenovo lenovo = new Lenovo(); //2.通过动态代理增强Lenovo对象 /* a.类加载器：真实对象.class.getClassLoader(); * b.接口数组：真实对象.class.getInterfaces(); * c.处理器：new InvocationHander()&#123;&#125;; */ // 返回的是一个代理对象，因为代理对象和真是对象实现相同的接口 SaleComputer proxy_lenovo = (SaleComputer) Proxy.newProxyInstance(Lenovo.class.getClassLoader(), Lenovo.class.getInterfaces(), new InvocationHandler() &#123; //代理逻辑编写的方法，代理对象调用的所有方法，都会执行该方法 /* proxy:代理对象 method:代理对象调用的方法，方法会被封装的对象，会被封装到method内 args:代理对象调用方法是实际传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// System.out.println(&quot;该方法被执行了&quot;);// System.out.println(method.getName());// System.out.println(args[0]); //判断是否是sale方法,是就增强 if(method.getName().equals(&quot;sale&quot;))&#123; //1.增强参数 double money = (double)args[0]; money = money*0.85; System.out.println(&quot;专车接........&quot;); Object object = method.invoke(lenovo,money); System.out.println(&quot;专车送货......&quot;); //2.增强返回值 return object+&quot;-------鼠标垫&quot;; &#125;else&#123;//不是sale方法不用增强 //使用真是对象调用该方法 Object object = method.invoke(lenovo,args); //return的返回值就是调用真实增强方法的返回值 return object; &#125; &#125; &#125;); //3.调用方法 String s = proxy_lenovo.sale(8000); System.out.println(s);// proxy_lenovo.show(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Listener学习]]></title>
    <url>%2F2019%2F07%2F18%2FListener%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Listener：监听器概念： web的三大组件之一，web监听器是一种Servlet中的特殊的类，它们能帮助开发者监听web中的特定 事件。比如ServletContext,HttpSession,ServletRequest的创建和销毁；变量的创建、销毁和修改等。 可以在某些动作前后增加处理，实现监控。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 *2 监听器常用的用途 通常使用Web监听器做以下的内容： 统计在线人数，利用HttpSessionLisener 加载初始化信息：利用ServletContextListener 统计网站访问量 实现访问监控 Listener:分类 * ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 12341. web.xml &lt;listener&gt; &lt;listener-class&gt;实现监听器接口的类路径&lt;/listener-class&gt; &lt;/listener&gt; 12345* 指定初始化参数 &lt;context-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/context-param&gt; 2. 注解： * @WebListener]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>监听器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter学习]]></title>
    <url>%2F2019%2F07%2F18%2Ffilter%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Filter：过滤器1. 概念：* 生活中的过滤器：净水器,空气净化器。 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤... 2. 快速入门：1. 步骤： 1. 定义一个类，实现接口Filter 2. 复写方法 3. 配置拦截路径 1. web.xml 2. 注解 1234567891011121314151617181920212223242. 代码： @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filterDemo1被执行了....&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;filterDemo1又被执行了....&quot;); &#125; @Override public void destroy() &#123; &#125; &#125; 3. 过滤器细节：1. web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 过滤器执行流程： 1. 执行过滤器。 2. 执行放行后的资源。 3. 回来执行过滤器放行代码下边的代码。 3. 过滤器生命周期方法 1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时，会执行。执行多次 3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源。 4. 过滤器配置详解 * 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置：资源被访问的方式 * 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源 * web.xml配置 * 设置&lt;h1&gt;&lt;dispatcher&gt;&lt;/dispatcher&gt;&lt;/h1&gt;标签即可。 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题： 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了。 2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml学习]]></title>
    <url>%2F2019%2F07%2F17%2Fxml%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[xml的学习1. 概念：Extensible Markup Language 可扩展标记语言* 可扩展：标签都是自定义的。 例如：&lt;user&gt; &lt;student&gt; * 功能 * 存储数据 1. 配置文件 2. 在网络中传输 * xml与html的区别 1. xml标签都是自定义的，html标签是预定义。 2. xml的语法严格，html语法松散 3. xml是存储数据的，html是展示数据 2. 语法：* 基本语法： 1. xml文档的后缀名 .xml 2. xml第一行必须定义为文档声明 3. xml文档中有且仅有一个根标签 4. 属性值必须使用引号(单双都可)引起来 5. 标签必须正确关闭 6. xml标签名称区分大小写 * 快速入门： 123456789101112131415&lt;?xml version=&apos;1.0&apos; ?&gt;&lt;users&gt; &lt;user id=&apos;1&apos;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id=&apos;2&apos;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; * 组成部分： 1. 文档声明 1. 格式：&lt;?xml 属性列表 ?&gt; 2. 属性列表： * version：版本号，必须的属性 * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 * standalone：是否独立 * 取值： * yes：不依赖其他文件 * no：依赖其他文件 2. 指令(了解)：结合css的 * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 3. 标签：标签名称自定义的 * 规则： * 名称可以包含字母、数字以及其他的字符 * 名称不能以数字或者标点符号开始 * 名称不能以字母 xml（或者 XML、Xml 等等）开始 * 名称不能包含空格 4. 属性： id属性值唯一 5. 文本： * CDATA区：在该区域中的数据会被原样展示 * 格式： &lt;![CDATA[ 数据 ]]&gt; * 约束：规定xml文档的书写规则 * 作为框架的使用者(程序员)： 1. 能够在xml中引入约束文档 2. 能够简单的读懂约束文档 * 分类： 1. DTD:一种简单的约束技术 2. Schema:一种复杂的约束技术 * DTD： * 引入dtd文档到xml文档中 * 内部dtd：将约束规则定义在xml文档中 * 外部dtd：将约束的规则定义在外部的dtd文件中 * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; * Schema: * 引入： 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3.引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot;&gt; 3. 解析：操作xml文档，将文档中的数据读取到内存中* 操作xml文档 1. 解析(读取)：将文档中的数据读取到内存中 2. 写入：将内存中的数据保存到xml文档中。持久化的存储 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;students&gt; &lt;student number=&quot;heima_0001&quot;&gt; &lt;name id=&quot;itcast&quot;&gt; &lt;xing&gt;张&lt;/xing&gt; &lt;ming&gt;三&lt;/ming&gt; &lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=&quot;heima_0002&quot;&gt; &lt;name&gt;jack&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; * 解析xml的方式： 1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 * 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 2. SAX：逐行读取，基于事件驱动的。 * 优点：不占内存。 * 缺点：只能读取，不能增删改 * xml常见的解析器： 1. JAXP：sun公司提供的解析器，支持dom和sax两种思想 2. DOM4J：一款非常优秀的解析器 3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 4. PULL：Android操作系统内置的解析器，sax方式的。 * Jsoup： * 快速入门： * 步骤： 1. 导入jar包 2. 获取Document对象 3. 获取对应的标签Element对象 4. 获取数据 代码： 123456789101112//2.1获取student.xml的pathString path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();//2.2解析xml文档，加载文档进内存，获取dom树---&gt;DocumentDocument document = Jsoup.parse(new File(path), &quot;utf-8&quot;);//3.获取元素对象 ElementElements elements = document.getElementsByTag(&quot;name&quot;);System.out.println(elements.size());//3.1获取第一个name的Element对象Element element = elements.get(0);//3.2获取数据String name = element.text();System.out.println(name); * 对象的使用： 1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse​(File in, String charsetName)：解析xml或html文件的。 * parse​(String html)：解析xml或html字符串 * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 * 获取Element对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 4. Element：元素对象 1. 获取子元素对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 2. 获取属性值 * String attr(String key)：根据属性名称获取属性值 3. 获取文本内容 * String text():获取文本内容 * String html():获取标签体的所有内容(包括字标签的字符串内容) 5. Node：节点对象 * 是Document和Element的父类 * 快捷查询方式： 1. selector:选择器 * 使用的方法：Elements select​(String cssQuery) * 语法：参考Selector类中定义的语法 1234567891011121314151617181920212223242526272829//1.获取student.xml的pathString path = JsoupDemo5.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();//2.获取Document对象Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);//3.查询name标签/* div&#123; &#125; */Elements elements = document.select(&quot;name&quot;);System.out.println(elements);System.out.println(&quot;=----------------&quot;);//4.查询id值为itcast的元素Elements elements1 = document.select(&quot;#itcast&quot;);System.out.println(elements1);System.out.println(&quot;----------------&quot;);//5.获取student标签并且number属性值为heima_0001的age子标签//5.1.获取student标签并且number属性值为heima_0001Elements elements2 = document.select(&quot;student[number=\&quot;heima_0001\&quot;]&quot;);System.out.println(elements2);System.out.println(&quot;----------------&quot;);//5.2获取student标签并且number属性值为heima_0001的age子标签Elements elements3 = document.select(&quot;student[number=\&quot;heima_0001\&quot;] &gt; age&quot;);System.out.println(elements3); 2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 * 使用Jsoup的Xpath需要额外导入jar包。 * 查询w3cshool参考手册，使用xpath的语法完成查询 * 代码： 12345678910111213141516171819202122232425262728293031323334353637//1.获取student.xml的pathString path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();//2.获取Document对象Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);//3.根据document对象，创建JXDocument对象JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询//4.1查询所有student标签List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode);&#125; System.out.println(&quot;--------------------&quot;); //4.2查询所有student标签下的name标签List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode);&#125; System.out.println(&quot;--------------------&quot;); //4.3查询student标签下带有id属性的name标签List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode);&#125;System.out.println(&quot;--------------------&quot;);//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;);for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode);&#125;]]></content>
      <categories>
        <category>xml</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习]]></title>
    <url>%2F2019%2F05%2F13%2FSpring%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Spring重要的模块？ Spring Core（）： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。Spring Aspects ： 该模块为与AspectJ的集成提供支持。Spring AOP ：提供了面向方面的编程实现。Spring JDBC : Java数据库连接。Spring JMS ：Java消息服务。Spring ORM : 用于支持Hibernate等ORM工具。Spring Web : 为创建Web应用程序提供支持。Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。 Spring IoC 和 AOP 的理解 IoC IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spirng 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 AOP AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示： 使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。 Spring AOP 和 AspectJ AOP 有什么区别？ Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。 Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单， 如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。 依赖注入（DI）和控制反转（IOC） 依赖注入（Dependency Injection）和控制反转（Inversion Of Control）实际上是一个概念。在传统的程序设计中，通常由调用者来创建被调用者的实例，而在依赖注入或控制反转的定义中，调用者不负责被调用者的实例创建工作，该工作由Spring框架中的容器来负责，它通过开发者的配置来判断实例的类型，创建后再注入调用者。由于Spring容器负责创建被调用者的实例，实例创建后又负责将该实例注入调用者，因此称作依赖注入（Dependency Injection），而被调用者的实例创建工作不再由调用者来创建而是由Spring来创建，因此也被称作控制反转（IOC）。 Spring 中的 bean 的作用域有哪些? singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。prototype : 每次请求都会创建一个新的 bean 实例。request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。 Spring 中的单例 bean 的线程安全问题了解吗？ 大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。 常见的有两种解决办法： 在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax与json的学习]]></title>
    <url>%2F2019%2F05%2F09%2FAjax%E4%B8%8Ejson%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Ajax和Json的学习Ajax（Asynchronous JavaScript and XML（异步的 JavaScript 和 XML））1. 异步和同步：客户端和服务器端相互通信的基础上 同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 Ajax作用AJAX 是与服务器交换数据并更新部分网页的技术，在不重新加载整个页面的情况下。提升用户的体验。 Ajax的概述AJAX 可以用于创建快速动态的网页。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 使用XHTML作为内容，CSS使用文档对象模型和JavaScript进行动态内容显示。 使用AJAX，当您点击提交时，JavaScript将向服务器发出请求，解释结果并更新当前屏幕。 当客户端程序在后台请求来自服务器的信息时，用户可以继续使用该应用程序。数据驱动而不是页面驱动。 Ajax的原理 使用原声js的Ajax技术 使用原声js的Ajax五大步骤：1.创建Ajax的引擎对象 2.为Ajax引擎绑定监听事件 3.绑定提交地址 4.发送请求 5.接受相应数据 原生的JS实现Ajax方式12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ajax.html&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function but1()&#123; //1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest)&#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else&#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2.绑定监听-----判断服务器数据是否已经返回 xmlHttp.onreadystatechange = function()&#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status==200) &#123; //5.接受响应数据 var date = xmlHttp.responseText; alert(date); &#125; &#125; //3.绑定地址 xmlHttp.open(&quot;GET&quot;,&quot;/Ajax/ajaxServlet&quot;,true);//地址，是否异步 //4.发送请求 xmlHttp.send(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;异步访问服务器&quot; onclick=&quot;but1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ajaxServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getWriter().write(&quot;hello wolrd nihao&quot;);; &#125;&#125; 使用JQuery的Ajax技术1. $.ajax() * 语法：$.ajax({键值对}); 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义方法 function fun() &#123; //使用$.ajax()发送异步请求 $.ajax(&#123; url:&quot;ajaxServlet1111&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(&quot;出错啦...&quot;) &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt; &lt;input&gt;&lt;/body&gt;&lt;/html&gt; 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义方法 function fun() &#123; $.get(&quot;ajaxServlet&quot;,&#123;username:&quot;rose&quot;&#125;,function (data) &#123; alert(data); &#125;,&quot;text&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt; &lt;input&gt;&lt;/body&gt;&lt;/html&gt; 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义方法 function fun() &#123; $.post(&quot;ajaxServlet&quot;,&#123;username:&quot;rose&quot;&#125;,function (data) &#123; alert(data); &#125;,&quot;text&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt; &lt;input&gt;&lt;/body&gt;&lt;/html&gt; Json（JavaScript Object Notation）JSON：JavaScript 对象表示法。 JSON 是轻量级的文本数据交换格式,独立于语言。 JSON是存储和交换文本信息的语法。类似 XML。 JSON比 XML更小、更快 更易解析。 Json的作用对于AJAX应用程序来说，JSON比XML更快更易使用： 使用 XML读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON 读取 JSON 字符串 用 eval() 处理 JSON 字符串 Json的格式与解析JSON 语法： *数据在名称/值对中：json数据是由键值对构成的 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） {&quot;persons&quot;:[{},{}]} 5. 对象（在花括号中） {&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}} 6. null *数据由逗号分隔：多个键值对由逗号分隔 *花括号保存对象：使用{}定义json 格式 *方括号保存数组：[] 定义格式1.定义基本格式 ———&gt; {} 1234var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true&#125;;//获取name的值var name1 = person.name;var name2 = person[&quot;name&quot;]; 2.嵌套格式 ———&gt; [{},{},{}] 12345var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;];//获取李四值alert(ps[1].name)； 3.嵌套格式 ———&gt; {&quot;&quot;:[{},{},{}]} 123456789var persons = &#123; &quot;persons&quot;: [ &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125; ]&#125;;//获取王五值var name1 = persons.persons[2].name; 数据获取1. json对象.键名 2. json对象[&quot;键名&quot;] 3. 数组对象[索引] 4. 遍历 遍历获取person对象中所有的键和值(for in 循环) 123456var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true&#125;;for(var key in person)&#123; //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]);&#125; 遍历获取ps中的所有值 123456789var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;];for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+&quot;:&quot;+p[key]); &#125;&#125; JSON数据和Java对象的相互转换* JSON解析器： * 常见的解析器：Jsonlib，Gson，fastjson，jackson 1. JSON转为Java对象1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. readValue(json字符串数据,Class) JSON字符串转为Java对象123456789101112@Testpublic void test5() throws Exception &#123; //1.初始化JSON字符串 String json = &quot;&#123;\&quot;gender\&quot;:\&quot;男\&quot;,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:23&#125;&quot;; //2.创建ObjectMapper对象 ObjectMapper mapper = new ObjectMapper(); //3.转换为Java对象 Person对象 Person person = mapper.readValue(json, Person.class); System.out.println(person);&#125; 2. Java对象转换JSON1. 使用步骤： 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串 2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致 Java对象转为JSON字符串 1234567891011121314151617181920@Testpublic void test1() throws Exception &#123; //1.创建Person对象 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); //2.创建Jackson的核心对象 ObjectMapper ObjectMapper mapper = new ObjectMapper(); //3.转换 String json = mapper.writeValueAsString(p); //System.out.println(json);//&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125; //writeValue，将数据写到d://a.txt文件中 //mapper.writeValue(new File(&quot;d://a.txt&quot;),p); //writeValue.将数据关联到Writer中 mapper.writeValue(new FileWriter(&quot;d://b.txt&quot;),p);&#125; 注解 123456789101112131415161718192021222324252627282930public class Person &#123; private String name; private int age ; private String gender; //@JsonIgnore // 忽略该属性 @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)//属性值得格式化 private Date birthday; //省略的get和set方法&#125;@Testpublic void test2() throws Exception &#123; //1.创建Person对象 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); p.setBirthday(new Date()); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(p); System.out.println(json); //&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:1530958029263&#125; //&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;&#125; 复杂java对象转换——List：数组 123456789101112131415161718192021222324252627282930313233343536373839404142 @Test public void test3() throws Exception &#123; //1.创建Person对象 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); p.setBirthday(new Date()); Person p1 = new Person(); p1.setName(&quot;张三&quot;); p1.setAge(23); p1.setGender(&quot;男&quot;); p1.setBirthday(new Date()); Person p2 = new Person(); p2.setName(&quot;张三&quot;); p2.setAge(23); p2.setGender(&quot;男&quot;); p2.setBirthday(new Date()); //1.创建List集合 List&lt;Person&gt; ps = new ArrayList&lt;Person&gt;(); ps.add(p); ps.add(p1); ps.add(p2); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(ps); // [&#123;&#125;,&#123;&#125;,&#123;&#125;] //[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;, &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;, &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;] System.out.println(json); &#125;``` - 复杂java对象转换------Map:对象格式一致 @Test public void test4() throws Exception { //1.创建map对象 Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put(&quot;name&quot;,&quot;张三&quot;); map.put(&quot;age&quot;,23); map.put(&quot;gender&quot;,&quot;男&quot;); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(map); System.out.println(json);//{&quot;gender&quot;:&quot;男&quot;,&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23} } `]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑hexo]]></title>
    <url>%2F2018%2F05%2F08%2F%E7%BC%96%E8%BE%91hexo%2F</url>
    <content type="text"><![CDATA[一级标题如何使用hexo编辑文章（二级标题）创建一个文章(heox n “文章名”)（三级标题） 字体是斜的 字体加粗字体 列表1 子列表a 子列表b 子列表c 子列表d 列表2 子列表a 子列表b 子列表c 子列表d 列表3 子列表a 子列表b 子列表c 子列表d JavaGuide学习-导航技术面试必备知识-导航 &lt;h1&gt;单行代码&lt;/h1&gt; 1234567public class Test &#123; public static void main(String []args)&#123; System.out.println(&quot;hello world&quot;); &#125;&#125; 我的是引用的]]></content>
      <categories>
        <category>编辑文章</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客文章]]></title>
    <url>%2F2017%2F05%2F07%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[关于hexo的安装与Github部署前言使用github pages服务搭建博客的好处有： 1.全是静态文件，访问速度快； 2.免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3.可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5.博客内容可以轻松打包、转移、发布到其它平台； 6.等等； 1.准备工作 ·有一个GitHub账号 ·安装了，git、node.js了解相关知识 2.创建仓库 新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 1.注册的邮箱一定要验证，否则不会成功； 2.仓库名字必须是：username.github.io，其中username是你的用户名； 3.仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 3.绑定域名 配置SSH key 为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 &lt;h1&gt;$ cd ~/. ssh #检查本机已存在的ssh密钥&lt;/h1&gt; 如果提示：No such file or directory 说明你是第一次使用git。 &lt;h1&gt;ssh-keygen -t rsa -C &quot;邮件地址&quot;&lt;/h1&gt; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 1.检测是否配置成功 使用hexo编写博客1.hexo简介 2.原理 3.注意事项 4.安装 5.初始化 6.修改主题 7.上传之前 8.上传到Github 9.保留CNAME、README.md等文件 10._config.yml 11.如何写博客 11.1写博客工具 11.2如何让博文列表不显示全部内容 hexo的常用命令1.常见命令() hexo n(new) &quot;postName&quot; #创建文章 hexo n(new) page &quot;pageName&quot; #创建页面 hexo g(generate) #生成静态页面之public目录 hexo s(server) #开启预访问端口(默认4000，&apos;ctrl+c&apos;关闭server) hexo d(deploy) #部署到Github hexo help #查看帮助 hexo v(version) #查看hexo版本 hexo clean #清理缓存 2.组合命令： hexo s -g #生成并本地浏览 hexo d -g #生成并上传 3.修改配置文件或修改创建博客命令行： a.hexo clean b.hexo g c.hexo d 参考文献https://dxd1392979164.github.io]]></content>
      <categories>
        <category>hexo安装</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2010%2F09%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. dxd的博客Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello world</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
</search>
