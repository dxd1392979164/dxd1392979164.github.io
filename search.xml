<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java的四种内部类]]></title>
    <url>%2F2019%2F08%2F10%2FJava%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java四种内部类因为之前复习到staic关键字，因为static修饰类只能修饰内部类，所以就对内部类进行了复习，所以写下这篇博客。 成员内部类成员内部类是最普通的内部类，它的定义为位于另一个类的内部。 一般格式如下,因为类C相对与类D在外面，我们且称类C为外部类。 12345class C&#123; class D&#123; &#125;&#125; 成员内部类的特性： 1.内部类可以无条件访问外部类的属性和方法（包括private成员和静态成员）。123456789101112131415161718192021class C &#123; private String name = &quot;外部类&quot;; private static String staticName = &quot;外部类的静态成员&quot;; public void run() &#123; System.out.println(&quot;外部类奔跑&quot;); &#125; public static void staticRun() &#123; System.out.println(&quot;外部类的静态方法&quot;); &#125; class D &#123; public void say() &#123; System.out.println(name); System.out.println(staticName); run(); staticRun(); &#125; &#125;&#125; 2.外部类想要访问内部类的属性和方法时就必须通过内部类的对象，通过对象访问。 123456789101112131415161718192021222324class C &#123; private String name = &quot;外部类&quot;; private static String staticName = &quot;外部类的静态成员&quot;; public void run() &#123; System.out.println(&quot;外部类奔跑&quot;); &#125; public static void staticRun() &#123; System.out.println(&quot;外部类的静态方法&quot;); &#125; public void test() &#123; D d = new D(); d.say(); &#125; class D &#123; public void say() &#123; System.out.println(name); System.out.println(staticName); run(); staticRun(); &#125; &#125;&#125; 3.如果成员内部类的属性或者方法与外部类的同名，将导致外部类的这些属性与方法在内部类被隐藏，需要按照该格式调用。 12外部类.this.成员变量外部类.this.成员方法 4.那如何创建一个内部类对象了? 前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125; class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 5.内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及默认访问权限。外部类只能被 public和包访问两种权限修饰。由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。 格式如下： 12345678class A &#123; public void testA() &#123; class B &#123;// 局部内部类 &#125; &#125;&#125; 注意: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。 匿名内部类1.匿名内部类也就是没有名字的内部类正因为没有名字。 2.所以匿名内部类只能使用一次，它通常用来简化代码编写。 3.但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。 1234567891011121314151617181920public class Demo3 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub driveCar(new Car() &#123; @Override public void drive() &#123; System.out.println(&quot;驾驶着汽车&quot;); &#125; &#125;); &#125; public static void driveCar(Car car) &#123; car.drive(); &#125;&#125;interface Car &#123; void drive();&#125; 注意： 匿名内部类不能定义任何静态成员、方法。 匿名内部类中的方法不能是抽象的； 匿名内部类必须实现接口或抽象父类的所有抽象方法。 匿名内部类访问的外部类成员变量或成员方法必须用static修饰； 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。这个内部类就属于外部类本身，而不属于外部类的某个对象。 1234567891011121314151617public class Demo4 &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125;class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; 注意： 1.非静态内部类中不允许定义静态成员 2.静态内部类不能使用外部类的非static成员变量或者方法]]></content>
      <categories>
        <category>Java学习总结</category>
      </categories>
      <tags>
        <tag>Java基础复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2019%2F08%2F09%2F%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式什么是单例设计模式？ 通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。并且自行实例化向整个系统提供。 懒汉式需要： （1）将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 （2）在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。 （3）定义一个静态方法返回这个唯一对象。 12345678910111213public class Monitor &#123; private static Monitor monitor = null; private Monitor() &#123;&#125; public static Monitor getMonitor() &#123; if(monitor == null) &#123; monitor = new Monitor(); &#125; return monitor; &#125;&#125; 优点：实现起来比较简单，当类Monitor被加载的时候，静态变量static的monitor未被创建并分配内存空间，当getMonitor方法第一次被调用时，初始化monitor变量，并分配内存，因此在某些特定条件下会节约了内存。 缺点：在多线程环境中，这种实现方法是完全错误的，根本不能保证单例的状态。上述代码还是不能保证一个班长实例的，因为存在线程安全问题。假如线程A执行到了monitor = new Monitor();，此时班长对象还没创建，线程B执行到判断 monitor == null时，条件为true，于是也进入到if里面去执行monitor = new Monitor();了，这样内存中就出现了两个班长实例了。 线程安全的懒汉模式12345678910111213public class Monitor &#123; private static Monitor monitor = null; private Monitor() &#123;&#125; // 静态方法返回该实例，加synchronized关键字实现同步 public static synchronized Monitor getMonitor() &#123; if (monitor == null) &#123; monitor = new Monitor(); &#125; return monitor; &#125;&#125; 优点：在多线程情形下，保证了“懒汉模式”的线程安全。 缺点：多线程情形下，synchronized方法通常效率低。 12345678910public static Monitor getMonitor() &#123; if (monitor == null) &#123; synchronized (Monitor.class) &#123; if (monitor == null) &#123; monitor = new Monitor(); &#125; &#125; &#125; return monitor;&#125; 第一层判断如果 monitor 实例不为空，那皆大欢喜，说明对象已经被创建过了，直接返回该对象即可，不会走到 synchronized 部分，所以班长对象被创建了之后，不会影响到性能。第二层判断是在 synchronized 代码块里面，为什么要再做一次判断呢？假如 monitor 对象是 null，那么第一层判断后，肯定有很多线程已经进来第一层了，那么即使在第二层某个线程执行完了之后，释放了锁，其他线程还会进入synchronized代码块，如果不判断，那么又会被创建一次，这就导致了多个班长对象的创建。所以第二层起到了一个防范作用。 饿汉式12345678910public class Monitor &#123; private static final Monitor monitor = new Monitor(); private Monitor() &#123;&#125; public static Monitor getMonitor() &#123; return monitor; &#125;&#125; 优点：实现起来简单，没有多线程同步问题。缺点：当类Monitor 被加载的时候，会初始化static的monitor，静态变量被创建并分配内存空间，从这以后，这个static的monitor对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。 饿汉式(静态代码块模式)1234567891011public class Monitor &#123; private static final Monitor monitor = null; static &#123; monitor = new Monitor(); &#125; private Monitor() &#123; &#125; public static final Monitor getInstance() &#123; return monitor; &#125;&#125; 这种静态代码块模式，本质上是饿汉模式的一个变种。 静态内部类班长这个对象有个属性是不会变的，那就是他所在的班级，所以班级可以直接定义好。如果想获取CLASS_INFO， 可以通过Monitor.CLASS_INFO,但是但是这样获取的话，因为都是static修饰的，调用Monitor.CLASS_INFO时， 也会执行构造方法将monitor对象初始化，但是我现在不想初始化班长对象（因为会影响性能） 12345678public class Monitor &#123; public static String CLASS_INFO = &quot;通信工程（1）班&quot;; private static Monitor monitor = new Monitor (); private Monitor () &#123;&#125; public static Monitor getMonitor() &#123; return monitor; &#125;&#125; 12345678910111213public class Monitor &#123; public static String CLASS_INFO = &quot;通信工程（1）班&quot;; /** * 静态内部类，用来创建班长对象 */ private static class MonitorCreator &#123; private static Monitor monitor = new Monitor(); &#125; private Monitor() &#123;&#125; public static Monitor getInstance() &#123; return MonitorCreator.monitor; &#125;&#125; 当执行getInstance()方法的时候会去调用内部类MoninorCreator里面的monitor的实例，此时MonitorCreator会 被加载、到内存，在类加载的时候对Monit实例进行初始化。而且当我使用Monitor.CLASS_INFO获取信息时，也不会对 monitor进行初始化。还确保了线程安全，因为JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线 程互斥的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月3]]></title>
    <url>%2F2019%2F08%2F03%2F8%E6%9C%883%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7月31]]></title>
    <url>%2F2019%2F07%2F31%2F7%E6%9C%8831%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7月27]]></title>
    <url>%2F2019%2F07%2F27%2F7%E6%9C%8827%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7月26]]></title>
    <url>%2F2019%2F07%2F26%2F7%E6%9C%8826%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7月24]]></title>
    <url>%2F2019%2F07%2F24%2F7%E6%9C%8824%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7月23]]></title>
    <url>%2F2019%2F07%2F23%2F7%E6%9C%8823%2F</url>
    <content type="text"></content>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F07%2F22%2F7%E6%9C%8822%2F</url>
    <content type="text"><![CDATA[Redis1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库。1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1.NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2.非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3.关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4.总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据。 1.2 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.2.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 2. 下载安装1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 4. 持久化1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 5. Java客户端 Jedis* Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string 123456789101112131415//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 12345678910111213141516171819202122232425//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) &#123; //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); &#125; //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 1234567891011121314151617181920212223242526//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 1234567891011121314//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 1234567891011121314151617//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 123456789101112131415//0.创建一个配置对象JedisPoolConfig config = new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdle(10); //1.创建Jedis连接池对象JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接Jedis jedis = jedisPool.getResource();//3. 使用jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中jedis.close(); * 连接池工具类 12345678910111213141516171819202122232425262728293031public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125;]]></content>
      <categories>
        <category>工具和中间件</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F07%2F21%2F7%E6%9C%8821%2F</url>
    <content type="text"><![CDATA[如何查看mysql的安装路径：在命令窗口中输入mysql命令时，提示“mysql不是内部命令也不是可运行的程序”，发现此问题是由于系统的环境变量中未配置MySQL安装目录可执行文件的路径，可是安装MySQL时是默认按照的，此时已经忘记了安装位置，各个盘符中找了一遍，都没有找到。那么要怎样找到其安装的路径呢？ 1.使用MySQL客户端查询 select @@basedir as basePath from dual 2.只需登录MySQL的客户端 输入命令：show variables like “%char%”;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java关键字]]></title>
    <url>%2F2019%2F07%2F20%2F7%E6%9C%8820%2F</url>
    <content type="text"><![CDATA[this关键字this关键字用于引用当前类实例。当一个对象创建后，Java虚拟机会为这个对象分配一个自身引用的指针，这个指针就是this。 a.使用this调用当前实例的变量。 b.使用this调用当前实例的方法（this可以省略） c.this调用本类中的其他构造方法，调用时要放在构造方法的首行。 d.this还可以返回类的引用。return this来返回某个类对象。 123456789101112131415161718public class Test32 &#123; private int number; public void changeNumber(int number) &#123; System.out.println(&quot;局部变量的number值为：&quot; + (number + 5)); System.out.println(&quot;成员变量的number值为：&quot; + (this.number + 2)); &#125; @Test public void test() &#123; int inputNum = 2; changeNumber(inputNum); &#125;&#125; 123456789101112131415161718public class Test32 &#123; private int number; public void changeNumber(int number) &#123; System.out.println(&quot;局部变量的number值为：&quot; + (number + 5)); System.out.println(&quot;成员变量的number值为：&quot; + (this.number + 2)); &#125; @Test public void test() &#123; int inputNum = 2; this.changeNumber(inputNum); &#125;&#125; 注意： 1.this调用构造方法必须放在首行。 2.this不能用在staic方法中，因为staic方法优先与对象存在。（static是在类加载的时候） 3.如果实例变量和局部变量重名时，Java会先按照局部变量，后实例变量去寻找，如果都找不到，则编译错误，如果使用this.a,则直接去实例变量中找； super关键字作用： 1.在子类中访问父类的的变量和方法。1234567891011121314public class Super &#123; protected int number; protected showNumber() &#123; System.out.println(&quot;number = &quot; + number); &#125;&#125; public class Sub extends Super &#123; void bar() &#123; super.number = 10; super.showNumber(); &#125;&#125; 在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。 2.在子类中访问父类的构造方法。如果子类没用通过super(参数列表)调用父类的构造方法，则会自动默认调用父类的无参构造方法，如果父类没用无参构造方法，此时会报错。 12345678910111213141516171819202122232425262728293031class Father &#123; int age ; public Father()&#123; &#125; public Father(int age) &#123; this.age = age; &#125; public void sayFather() &#123; System.out.println(age); &#125;&#125;class Son extends Father &#123; public String name; public Son() &#123; super();//不写默认调用 &#125; public Son(String name) &#123; super(25); this.name = name; &#125; public String say() &#123; super.sayFather(); System.out.println(super.age); return this.name; &#125;&#125; 注意： 1.访问父类的构造方法时必须放在首行，不写默认调用父类无参构造。 使用 this 和 super 要注意的问题： 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。this、super不能用在static方法中。 static关键字static关键字主要用在三个地方：方法，变量，静态代码块，类，静态导包； 1.修饰成员变量和成员方法：使用static修饰的方法或变量是属于类，不属于单个对象，是所有对象共享的。并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()。 2.静态代码块：静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次。非静态代码块没new一次就会执行一次。非静态代码块是给所有对象进行初始化。构造方法是给对应的对象进行初始化。 3.静态内部类（static修饰的类只能是静态内部类）：静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 4.静态导包(用来导入类中的静态资源，1.5之后的新特性):格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 final关键字final关键主要用在三个地方：变量，方法，类。 1.修饰变量：如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 2.当用final修饰一个类时：表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 3.final修饰方法时：是把方法锁定，以防任何继承类修改它的含义；类中所有的private方法都隐式地指定为final。]]></content>
      <categories>
        <category>Java学习总结</category>
      </categories>
      <tags>
        <tag>Java基础复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理设计模式]]></title>
    <url>%2F2019%2F07%2F19%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[静态代理设计模式： 要求： 1.要有真实角色。 2.要有代理角色。 3.两者实现相同的接口，向代理传入真实角色的引用。 4.调用代理的方法。 在Java中线程的设计就使用了静态代理设计模式，其中自定义线程类实现Runable接口，Thread类也实现了Runalbe接口，在创建子线程的时候，传入了自定义线程类的引用，再通过调用start()方法，调用自定义线程对象的run()方法。实现了线程的并发执行。123456789101112131415161718192021public class Test2 &#123; public static void main(String[] args) &#123; //Runnable实现类对象，真实角色 Thread1 role1 = new Thread1(); //线程类代理角色，该类也实现了Runnable接口，代理角色 Thread thread1 = new Thread(role1);//传入了真实角色的引用 thread1.start(); &#125; &#125; class Thread1 implements Runnable &#123; @Override public void run() &#123; //TODO &#125; &#125; Thread对象调用线程的start（）方法，在内部调用了真实角色的run()方法 设计静态代理模式 第一步，要有一个共同使用的接口1234// 共同的接口public interface Proxy &#123; public abstract void todo();&#125; 代理角色和真实角色共同实现该接口,代理角色实现需要的功能。 12345678// 真实角色 class RealityRole implements Proxy &#123; @Override public void todo() &#123; System.out.println(&quot;真实角色的功能&quot;); &#125; &#125; 123456789101112131415161718192021222324252627282930// 代理角色 class ProxyRole implements Proxy &#123; // 持有代理角色的引用 private Proxy realityRole; public ProxyRole() &#123; &#125; //传入一个真实角色 public ProxyRole(Proxy role) &#123; realityRole = role; &#125; @Override public void todo() &#123; //在真实角色功能运行之前，代理角色做准备工作 doBefore(); //执行真实角色的功能 realityRole.todo(); //代理角色的收尾工作 doAfter(); &#125; private void doBefore() &#123; System.out.println(&quot;准备工作&quot;); &#125; private void doAfter() &#123; System.out.println(&quot;收尾工作&quot;); &#125; &#125; 创建真实角色的对象和代理角色的对象，并将真实角色对象的引用传给代理角色，让代理角色去执行功能。 123456789101112 public class Test &#123; public static void main(String[] args) &#123; //创建真实角色对象 Proxy realityRole = new RealityRole(); //创建代理角色对象，并制定真实对象 ProxyRole proxyRole = new ProxyRole(realityRole); //代理角色工作，本质调用的还是真实角色的功能 proxyRole.todo(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理设计模式]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式：一些通用的解决固定问题的方式 增强对象的功能： 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 定义的接口1234567public interface SaleComputer &#123; public String sale(double money); public void show();&#125; 12345678910111213141516/** * 这是真实类 */public class Lenovo implements SaleComputer &#123; @Override public String sale(double money) &#123; System.out.println(&quot;买了一台电脑&quot;+money+&quot;元的联想电脑&quot;); return &quot;联想电脑&quot;; &#125; @Override public void show() &#123; System.out.println(&quot;展示电脑！&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class LenovoProxy &#123; public static void main(String [] args)&#123; //1.创建真实对象 Lenovo lenovo = new Lenovo(); //2.通过动态代理增强Lenovo对象 /* a.类加载器：真实对象.class.getClassLoader(); * b.接口数组：真实对象.class.getInterfaces(); * c.处理器：new InvocationHander()&#123;&#125;; */ // 返回的是一个代理对象，因为代理对象和真是对象实现相同的接口 SaleComputer proxy_lenovo = (SaleComputer) Proxy.newProxyInstance(Lenovo.class.getClassLoader(), Lenovo.class.getInterfaces(), new InvocationHandler() &#123; //代理逻辑编写的方法，代理对象调用的所有方法，都会执行该方法 /* proxy:代理对象 method:代理对象调用的方法，方法会被封装的对象，会被封装到method内 args:代理对象调用方法是实际传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// System.out.println(&quot;该方法被执行了&quot;);// System.out.println(method.getName());// System.out.println(args[0]); //判断是否是sale方法,是就增强 if(method.getName().equals(&quot;sale&quot;))&#123; //1.增强参数 double money = (double)args[0]; money = money*0.85; System.out.println(&quot;专车接........&quot;); Object object = method.invoke(lenovo,money); System.out.println(&quot;专车送货......&quot;); //2.增强返回值 return object+&quot;-------鼠标垫&quot;; &#125;else&#123;//不是sale方法不用增强 //使用真是对象调用该方法 Object object = method.invoke(lenovo,args); //return的返回值就是调用真实增强方法的返回值 return object; &#125; &#125; &#125;); //3.调用方法 String s = proxy_lenovo.sale(8000); System.out.println(s);// proxy_lenovo.show(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Listener学习]]></title>
    <url>%2F2019%2F07%2F18%2FListener%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Listener：监听器概念： web的三大组件之一，web监听器是一种Servlet中的特殊的类，它们能帮助开发者监听web中的特定 事件。比如ServletContext,HttpSession,ServletRequest的创建和销毁；变量的创建、销毁和修改等。 可以在某些动作前后增加处理，实现监控。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 *2 监听器常用的用途 通常使用Web监听器做以下的内容： 统计在线人数，利用HttpSessionLisener 加载初始化信息：利用ServletContextListener 统计网站访问量 实现访问监控 Listener:分类 * ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 12341. web.xml &lt;listener&gt; &lt;listener-class&gt;实现监听器接口的类路径&lt;/listener-class&gt; &lt;/listener&gt; 12345* 指定初始化参数 &lt;context-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/context-param&gt; 2. 注解： * @WebListener]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>监听器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter学习]]></title>
    <url>%2F2019%2F07%2F18%2Ffilter%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Filter：过滤器1. 概念：* 生活中的过滤器：净水器,空气净化器。 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤... 2. 快速入门：1. 步骤： 1. 定义一个类，实现接口Filter 2. 复写方法 3. 配置拦截路径 1. web.xml 2. 注解 1234567891011121314151617181920212223242. 代码： @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filterDemo1被执行了....&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;filterDemo1又被执行了....&quot;); &#125; @Override public void destroy() &#123; &#125; &#125; 3. 过滤器细节：1. web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 过滤器执行流程： 1. 执行过滤器。 2. 执行放行后的资源。 3. 回来执行过滤器放行代码下边的代码。 3. 过滤器生命周期方法 1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时，会执行。执行多次 3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源。 4. 过滤器配置详解 * 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置：资源被访问的方式 * 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源 * web.xml配置 * 设置&lt;h1&gt;&lt;dispatcher&gt;&lt;/dispatcher&gt;&lt;/h1&gt;标签即可。 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题： 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了。 2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml学习]]></title>
    <url>%2F2019%2F07%2F17%2Fxml%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[xml的学习1. 概念：Extensible Markup Language 可扩展标记语言* 可扩展：标签都是自定义的。 例如：&lt;user&gt; &lt;student&gt; * 功能 * 存储数据 1. 配置文件 2. 在网络中传输 * xml与html的区别 1. xml标签都是自定义的，html标签是预定义。 2. xml的语法严格，html语法松散 3. xml是存储数据的，html是展示数据 2. 语法：* 基本语法： 1. xml文档的后缀名 .xml 2. xml第一行必须定义为文档声明 3. xml文档中有且仅有一个根标签 4. 属性值必须使用引号(单双都可)引起来 5. 标签必须正确关闭 6. xml标签名称区分大小写 * 快速入门： 123456789101112131415&lt;?xml version=&apos;1.0&apos; ?&gt;&lt;users&gt; &lt;user id=&apos;1&apos;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id=&apos;2&apos;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; * 组成部分： 1. 文档声明 1. 格式：&lt;?xml 属性列表 ?&gt; 2. 属性列表： * version：版本号，必须的属性 * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 * standalone：是否独立 * 取值： * yes：不依赖其他文件 * no：依赖其他文件 2. 指令(了解)：结合css的 * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 3. 标签：标签名称自定义的 * 规则： * 名称可以包含字母、数字以及其他的字符 * 名称不能以数字或者标点符号开始 * 名称不能以字母 xml（或者 XML、Xml 等等）开始 * 名称不能包含空格 4. 属性： id属性值唯一 5. 文本： * CDATA区：在该区域中的数据会被原样展示 * 格式： &lt;![CDATA[ 数据 ]]&gt; * 约束：规定xml文档的书写规则 * 作为框架的使用者(程序员)： 1. 能够在xml中引入约束文档 2. 能够简单的读懂约束文档 * 分类： 1. DTD:一种简单的约束技术 2. Schema:一种复杂的约束技术 * DTD： * 引入dtd文档到xml文档中 * 内部dtd：将约束规则定义在xml文档中 * 外部dtd：将约束的规则定义在外部的dtd文件中 * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; * Schema: * 引入： 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3.引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot;&gt; 3. 解析：操作xml文档，将文档中的数据读取到内存中* 操作xml文档 1. 解析(读取)：将文档中的数据读取到内存中 2. 写入：将内存中的数据保存到xml文档中。持久化的存储 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;students&gt; &lt;student number=&quot;heima_0001&quot;&gt; &lt;name id=&quot;itcast&quot;&gt; &lt;xing&gt;张&lt;/xing&gt; &lt;ming&gt;三&lt;/ming&gt; &lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=&quot;heima_0002&quot;&gt; &lt;name&gt;jack&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; * 解析xml的方式： 1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 * 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 2. SAX：逐行读取，基于事件驱动的。 * 优点：不占内存。 * 缺点：只能读取，不能增删改 * xml常见的解析器： 1. JAXP：sun公司提供的解析器，支持dom和sax两种思想 2. DOM4J：一款非常优秀的解析器 3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 4. PULL：Android操作系统内置的解析器，sax方式的。 * Jsoup： * 快速入门： * 步骤： 1. 导入jar包 2. 获取Document对象 3. 获取对应的标签Element对象 4. 获取数据 代码： 123456789101112//2.1获取student.xml的pathString path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();//2.2解析xml文档，加载文档进内存，获取dom树---&gt;DocumentDocument document = Jsoup.parse(new File(path), &quot;utf-8&quot;);//3.获取元素对象 ElementElements elements = document.getElementsByTag(&quot;name&quot;);System.out.println(elements.size());//3.1获取第一个name的Element对象Element element = elements.get(0);//3.2获取数据String name = element.text();System.out.println(name); * 对象的使用： 1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse​(File in, String charsetName)：解析xml或html文件的。 * parse​(String html)：解析xml或html字符串 * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 * 获取Element对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 4. Element：元素对象 1. 获取子元素对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 2. 获取属性值 * String attr(String key)：根据属性名称获取属性值 3. 获取文本内容 * String text():获取文本内容 * String html():获取标签体的所有内容(包括字标签的字符串内容) 5. Node：节点对象 * 是Document和Element的父类 * 快捷查询方式： 1. selector:选择器 * 使用的方法：Elements select​(String cssQuery) * 语法：参考Selector类中定义的语法 1234567891011121314151617181920212223242526272829//1.获取student.xml的pathString path = JsoupDemo5.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();//2.获取Document对象Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);//3.查询name标签/* div&#123; &#125; */Elements elements = document.select(&quot;name&quot;);System.out.println(elements);System.out.println(&quot;=----------------&quot;);//4.查询id值为itcast的元素Elements elements1 = document.select(&quot;#itcast&quot;);System.out.println(elements1);System.out.println(&quot;----------------&quot;);//5.获取student标签并且number属性值为heima_0001的age子标签//5.1.获取student标签并且number属性值为heima_0001Elements elements2 = document.select(&quot;student[number=\&quot;heima_0001\&quot;]&quot;);System.out.println(elements2);System.out.println(&quot;----------------&quot;);//5.2获取student标签并且number属性值为heima_0001的age子标签Elements elements3 = document.select(&quot;student[number=\&quot;heima_0001\&quot;] &gt; age&quot;);System.out.println(elements3); 2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 * 使用Jsoup的Xpath需要额外导入jar包。 * 查询w3cshool参考手册，使用xpath的语法完成查询 * 代码： 12345678910111213141516171819202122232425262728293031323334353637//1.获取student.xml的pathString path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();//2.获取Document对象Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);//3.根据document对象，创建JXDocument对象JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询//4.1查询所有student标签List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode);&#125; System.out.println(&quot;--------------------&quot;); //4.2查询所有student标签下的name标签List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode);&#125; System.out.println(&quot;--------------------&quot;); //4.3查询student标签下带有id属性的name标签List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode);&#125;System.out.println(&quot;--------------------&quot;);//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;);for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode);&#125;]]></content>
      <categories>
        <category>xml</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习]]></title>
    <url>%2F2019%2F05%2F13%2Fspring%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Spring学习笔记]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax与json的学习]]></title>
    <url>%2F2019%2F05%2F09%2FAjax%E4%B8%8Ejson%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Ajax和Json的学习Ajax（Asynchronous JavaScript and XML（异步的 JavaScript 和 XML））1. 异步和同步：客户端和服务器端相互通信的基础上 同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 Ajax作用AJAX 是与服务器交换数据并更新部分网页的技术，在不重新加载整个页面的情况下。提升用户的体验。 Ajax的概述AJAX 可以用于创建快速动态的网页。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 使用XHTML作为内容，CSS使用文档对象模型和JavaScript进行动态内容显示。 使用AJAX，当您点击提交时，JavaScript将向服务器发出请求，解释结果并更新当前屏幕。 当客户端程序在后台请求来自服务器的信息时，用户可以继续使用该应用程序。数据驱动而不是页面驱动。 Ajax的原理 使用原声js的Ajax技术 使用原声js的Ajax五大步骤：1.创建Ajax的引擎对象 2.为Ajax引擎绑定监听事件 3.绑定提交地址 4.发送请求 5.接受相应数据 原生的JS实现Ajax方式12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ajax.html&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function but1()&#123; //1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest)&#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else&#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2.绑定监听-----判断服务器数据是否已经返回 xmlHttp.onreadystatechange = function()&#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status==200) &#123; //5.接受响应数据 var date = xmlHttp.responseText; alert(date); &#125; &#125; //3.绑定地址 xmlHttp.open(&quot;GET&quot;,&quot;/Ajax/ajaxServlet&quot;,true);//地址，是否异步 //4.发送请求 xmlHttp.send(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;异步访问服务器&quot; onclick=&quot;but1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ajaxServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getWriter().write(&quot;hello wolrd nihao&quot;);; &#125;&#125; 使用JQuery的Ajax技术1. $.ajax() * 语法：$.ajax({键值对}); 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义方法 function fun() &#123; //使用$.ajax()发送异步请求 $.ajax(&#123; url:&quot;ajaxServlet1111&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(&quot;出错啦...&quot;) &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt; &lt;input&gt;&lt;/body&gt;&lt;/html&gt; 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义方法 function fun() &#123; $.get(&quot;ajaxServlet&quot;,&#123;username:&quot;rose&quot;&#125;,function (data) &#123; alert(data); &#125;,&quot;text&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt; &lt;input&gt;&lt;/body&gt;&lt;/html&gt; 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //定义方法 function fun() &#123; $.post(&quot;ajaxServlet&quot;,&#123;username:&quot;rose&quot;&#125;,function (data) &#123; alert(data); &#125;,&quot;text&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt; &lt;input&gt;&lt;/body&gt;&lt;/html&gt; Json（JavaScript Object Notation）JSON：JavaScript 对象表示法。 JSON 是轻量级的文本数据交换格式,独立于语言。 JSON是存储和交换文本信息的语法。类似 XML。 JSON比 XML更小、更快 更易解析。 Json的作用对于AJAX应用程序来说，JSON比XML更快更易使用： 使用 XML读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON 读取 JSON 字符串 用 eval() 处理 JSON 字符串 Json的格式与解析JSON 语法： *数据在名称/值对中：json数据是由键值对构成的 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） {&quot;persons&quot;:[{},{}]} 5. 对象（在花括号中） {&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}} 6. null *数据由逗号分隔：多个键值对由逗号分隔 *花括号保存对象：使用{}定义json 格式 *方括号保存数组：[] 定义格式1.定义基本格式 ———&gt; {} 1234var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true&#125;;//获取name的值var name1 = person.name;var name2 = person[&quot;name&quot;]; 2.嵌套格式 ———&gt; [{},{},{}] 12345var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;];//获取李四值alert(ps[1].name)； 3.嵌套格式 ———&gt; {&quot;&quot;:[{},{},{}]} 123456789var persons = &#123; &quot;persons&quot;: [ &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125; ]&#125;;//获取王五值var name1 = persons.persons[2].name; 数据获取1. json对象.键名 2. json对象[&quot;键名&quot;] 3. 数组对象[索引] 4. 遍历 遍历获取person对象中所有的键和值(for in 循环) 123456var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true&#125;;for(var key in person)&#123; //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]);&#125; 遍历获取ps中的所有值 123456789var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;];for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+&quot;:&quot;+p[key]); &#125;&#125; JSON数据和Java对象的相互转换* JSON解析器： * 常见的解析器：Jsonlib，Gson，fastjson，jackson 1. JSON转为Java对象1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. readValue(json字符串数据,Class) JSON字符串转为Java对象123456789101112@Testpublic void test5() throws Exception &#123; //1.初始化JSON字符串 String json = &quot;&#123;\&quot;gender\&quot;:\&quot;男\&quot;,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:23&#125;&quot;; //2.创建ObjectMapper对象 ObjectMapper mapper = new ObjectMapper(); //3.转换为Java对象 Person对象 Person person = mapper.readValue(json, Person.class); System.out.println(person);&#125; 2. Java对象转换JSON1. 使用步骤： 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串 2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致 Java对象转为JSON字符串 1234567891011121314151617181920@Testpublic void test1() throws Exception &#123; //1.创建Person对象 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); //2.创建Jackson的核心对象 ObjectMapper ObjectMapper mapper = new ObjectMapper(); //3.转换 String json = mapper.writeValueAsString(p); //System.out.println(json);//&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125; //writeValue，将数据写到d://a.txt文件中 //mapper.writeValue(new File(&quot;d://a.txt&quot;),p); //writeValue.将数据关联到Writer中 mapper.writeValue(new FileWriter(&quot;d://b.txt&quot;),p);&#125; 注解 123456789101112131415161718192021222324252627282930public class Person &#123; private String name; private int age ; private String gender; //@JsonIgnore // 忽略该属性 @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)//属性值得格式化 private Date birthday; //省略的get和set方法&#125;@Testpublic void test2() throws Exception &#123; //1.创建Person对象 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); p.setBirthday(new Date()); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(p); System.out.println(json); //&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:1530958029263&#125; //&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;&#125; 复杂java对象转换——List：数组 123456789101112131415161718192021222324252627282930313233343536373839404142 @Test public void test3() throws Exception &#123; //1.创建Person对象 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); p.setBirthday(new Date()); Person p1 = new Person(); p1.setName(&quot;张三&quot;); p1.setAge(23); p1.setGender(&quot;男&quot;); p1.setBirthday(new Date()); Person p2 = new Person(); p2.setName(&quot;张三&quot;); p2.setAge(23); p2.setGender(&quot;男&quot;); p2.setBirthday(new Date()); //1.创建List集合 List&lt;Person&gt; ps = new ArrayList&lt;Person&gt;(); ps.add(p); ps.add(p1); ps.add(p2); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(ps); // [&#123;&#125;,&#123;&#125;,&#123;&#125;] //[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;, &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;, &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;,&quot;birthday&quot;:&quot;2018-07-07&quot;&#125;] System.out.println(json); &#125;``` - 复杂java对象转换------Map:对象格式一致 @Test public void test4() throws Exception { //1.创建map对象 Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put(&quot;name&quot;,&quot;张三&quot;); map.put(&quot;age&quot;,23); map.put(&quot;gender&quot;,&quot;男&quot;); //2.转换 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(map); System.out.println(json);//{&quot;gender&quot;:&quot;男&quot;,&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23} } `]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑hexo]]></title>
    <url>%2F2018%2F05%2F08%2F%E7%BC%96%E8%BE%91hexo%2F</url>
    <content type="text"><![CDATA[一级标题如何使用hexo编辑文章（二级标题）创建一个文章(heox n “文章名”)（三级标题） 字体是斜的 字体加粗字体 列表1 子列表a 子列表b 子列表c 子列表d 列表2 子列表a 子列表b 子列表c 子列表d 列表3 子列表a 子列表b 子列表c 子列表d JavaGuide学习-导航技术面试必备知识-导航 &lt;h1&gt;单行代码&lt;/h1&gt; 1234567public class Test &#123; public static void main(String []args)&#123; System.out.println(&quot;hello world&quot;); &#125;&#125; 我的是引用的]]></content>
      <categories>
        <category>编辑文章</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客文章]]></title>
    <url>%2F2017%2F05%2F07%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[关于hexo的安装与Github部署前言使用github pages服务搭建博客的好处有： 1.全是静态文件，访问速度快； 2.免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3.可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5.博客内容可以轻松打包、转移、发布到其它平台； 6.等等； 1.准备工作 ·有一个GitHub账号 ·安装了，git、node.js了解相关知识 2.创建仓库 新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 1.注册的邮箱一定要验证，否则不会成功； 2.仓库名字必须是：username.github.io，其中username是你的用户名； 3.仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 3.绑定域名 配置SSH key 为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 &lt;h1&gt;$ cd ~/. ssh #检查本机已存在的ssh密钥&lt;/h1&gt; 如果提示：No such file or directory 说明你是第一次使用git。 &lt;h1&gt;ssh-keygen -t rsa -C &quot;邮件地址&quot;&lt;/h1&gt; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 1.检测是否配置成功 使用hexo编写博客1.hexo简介 2.原理 3.注意事项 4.安装 5.初始化 6.修改主题 7.上传之前 8.上传到Github 9.保留CNAME、README.md等文件 10._config.yml 11.如何写博客 11.1写博客工具 11.2如何让博文列表不显示全部内容 hexo的常用命令1.常见命令() hexo n(new) &quot;postName&quot; #创建文章 hexo n(new) page &quot;pageName&quot; #创建页面 hexo g(generate) #生成静态页面之public目录 hexo s(server) #开启预访问端口(默认4000，&apos;ctrl+c&apos;关闭server) hexo d(deploy) #部署到Github hexo help #查看帮助 hexo v(version) #查看hexo版本 hexo clean #清理缓存 2.组合命令： hexo s -g #生成并本地浏览 hexo d -g #生成并上传 3.修改配置文件或修改创建博客命令行： a.hexo clean b.hexo g c.hexo d 参考文献https://dxd1392979164.github.io]]></content>
      <categories>
        <category>hexo安装</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2010%2F09%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. dxd的博客Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello world</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
</search>
